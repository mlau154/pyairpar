<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyairpar.core.airfoil API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyairpar.core.airfoil</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from pyairpar.core.param import Param
from pyairpar.core.anchor_point import AnchorPoint
from pyairpar.core.free_point import FreePoint
from pyairpar.core.base_airfoil_params import BaseAirfoilParams
from pyairpar.symmetric.symmetric_base_airfoil_params import SymmetricBaseAirfoilParams
from matplotlib.axes import Axes
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import typing
from shapely.geometry import Polygon, LineString


class Airfoil:

    def __init__(self,
                 number_coordinates: int = 100,
                 base_airfoil_params: BaseAirfoilParams or SymmetricBaseAirfoilParams = BaseAirfoilParams(),
                 anchor_point_tuple: typing.Tuple[AnchorPoint, ...] = (),
                 free_point_tuple: typing.Tuple[FreePoint, ...] = (),
                 override_parameters: list = None
                 ):
        &#34;&#34;&#34;
        ### Description:

        `pyairpar.core.airfoil.Airfoil` is the base class for Bézier-parametrized airfoil creation.

        ### Args:

        `number_coordinates`: an `int` representing the number of discrete \\(x\\) - \\(y\\) coordinate pairs in each
        Bézier curve. Gets passed to the `bezier` function.

        `base_airfoil_params`: an instance of either the `pyairpar.core.base_airfoil_params.BaseAirfoilParams` class or
        the `pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams` class which defines the base
        set of parameters to be used

        `anchor_point_tuple`: a `tuple` of `pyairpar.core.anchor_point.AnchorPoint` objects. To specify a single
        anchor point, use `(pyairpar.core.anchor_point.AnchorPoint(),)`. Default: `()`

        `free_point_tuple`: a `tuple` of `pyairpar.core.free_point.FreePoint` objects. To specify a single free
        point, use `(pyairpar.core.free_point.FreePoint(),)`. Default: `()`

        ### Returns:

        An instance of the `Airfoil` class
        &#34;&#34;&#34;

        self.nt = number_coordinates
        self.params = []
        self.bounds = []
        self.base_airfoil_params = base_airfoil_params
        self.override_parameters = override_parameters

        self.override_parameter_start_idx = 0
        self.override_parameter_end_idx = self.base_airfoil_params.n_overrideable_parameters
        if self.override_parameters is not None:
            self.base_airfoil_params.override(
                self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
        self.override_parameter_start_idx += self.base_airfoil_params.n_overrideable_parameters

        self.c = base_airfoil_params.c
        self.alf = base_airfoil_params.alf
        self.R_le = base_airfoil_params.R_le
        self.L_le = base_airfoil_params.L_le
        self.r_le = base_airfoil_params.r_le
        self.phi_le = base_airfoil_params.phi_le
        self.psi1_le = base_airfoil_params.psi1_le
        self.psi2_le = base_airfoil_params.psi2_le
        self.L1_te = base_airfoil_params.L1_te
        self.L2_te = base_airfoil_params.L2_te
        self.theta1_te = base_airfoil_params.theta1_te
        self.theta2_te = base_airfoil_params.theta2_te
        self.t_te = base_airfoil_params.t_te
        self.r_te = base_airfoil_params.r_te
        self.phi_te = base_airfoil_params.phi_te
        self.dx = base_airfoil_params.dx
        self.dy = base_airfoil_params.dy

        # Ensure that all the trailing edge parameters are no longer active if the trailing edge thickness is set to 0.0
        if self.t_te.value == 0.0:
            self.r_te.active = False
            self.phi_te.active = False

        self.C = []
        self.free_points = {}
        self.param_dicts = {}
        self.coords = None
        self.curvature = None
        self.area = None
        self.needs_update = True

        self.anchor_point_tuple = anchor_point_tuple

        if self.override_parameters is not None:
            for anchor_point in self.anchor_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    anchor_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  anchor_point.n_overrideable_parameters
                anchor_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += anchor_point.n_overrideable_parameters

        self.free_point_tuple = free_point_tuple

        if self.override_parameters is not None:
            for free_point in self.free_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    free_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  free_point.n_overrideable_parameters
                free_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += free_point.n_overrideable_parameters

        self.anchor_points = {&#39;te_1&#39;: self.c.value * np.array([1, 0]) + self.r_te.value * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)]),
                              &#39;le&#39;: np.array([0.0, 0.0]),
                              &#39;te_2&#39;: self.c.value * np.array([1, 0]) -
                                      (1 - self.r_te.value) * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)])}
        self.anchor_point_order = [&#39;te_1&#39;, &#39;le&#39;, &#39;te_2&#39;]
        self.anchor_point_array = np.array([])

        self.N = {
            &#39;te_1&#39;: 4,
            &#39;le&#39;: 4
        }

        self.control_points = np.array([])
        self.n_control_points = len(self.control_points)

        self.g1_minus_points, self.g1_plus_points = self.init_g1_points()
        self.g2_minus_points, self.g2_plus_points = self.init_g2_points()

        self.update()

    def init_g1_points(self):

        g1_minus_points = {
            &#39;te_2&#39;: self.anchor_points[&#39;te_2&#39;] +
                  self.L2_te.value * np.array([-np.cos(self.theta2_te.value),
                                               -np.sin(self.theta2_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] +
                  self.r_le.value * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        g1_plus_points = {
            &#39;te_1&#39;: self.anchor_points[&#39;te_1&#39;] +
                    self.L1_te.value * np.array([-np.cos(self.theta1_te.value),
                                                 np.sin(self.theta1_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] -
                  (1 - self.r_le.value) * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        return g1_minus_points, g1_plus_points

    def init_g2_points(self):
        g2_minus_point_le, g2_plus_point_le = self.set_curvature_le()

        g2_minus_points = {
            &#39;le&#39;: g2_minus_point_le
        }

        g2_plus_points = {
            &#39;le&#39;: g2_plus_point_le
        }

        return g2_minus_points, g2_plus_points

    def set_slope(self, anchor_point: AnchorPoint):
        phi = anchor_point.phi.value
        r = anchor_point.r.value
        L = anchor_point.L.value

        if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + r * L * np.array([np.cos(phi), np.sin(phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
        else:
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(phi), np.sin(phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
        return self.g1_minus_points, self.g1_plus_points

    def set_curvature_le(self):
        if self.R_le.value == np.inf:
            g2_minus_point = self.g1_minus_points[&#39;le&#39;]
            g2_plus_point = self.g1_plus_points[&#39;le&#39;]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(&#39;le&#39;) - 1]], self.N[&#39;le&#39;]
            theta1, theta2 = self.psi1_le.value, -self.psi2_le.value
            x0, y0 = self.anchor_points[&#39;le&#39;][0], self.anchor_points[&#39;le&#39;][1]

            x_m1, y_m1 = self.g1_minus_points[&#39;le&#39;][0], self.g1_minus_points[&#39;le&#39;][1]
            g2_minus_point = np.zeros(2)
            g2_minus_point[0] = x_m1 - 1 / self.R_le.value * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3/2) / (
                                1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

            x_p1, y_p1 = self.g1_plus_points[&#39;le&#39;][0], self.g1_plus_points[&#39;le&#39;][1]
            g2_plus_point = np.zeros(2)
            g2_plus_point[0] = x_p1 - 1 / self.R_le.value * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3/2) / (
                               1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

        return g2_minus_point, g2_plus_point

    def set_curvature(self, anchor_point: AnchorPoint):
        R = anchor_point.R.value
        if R == np.inf:
            self.g2_minus_points[anchor_point.name] = self.g1_minus_points[anchor_point.name]
            self.g2_plus_points[anchor_point.name] = self.g1_plus_points[anchor_point.name]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(anchor_point.name) - 1]], \
                     self.N[anchor_point.name]
            if R &gt; 0:
                theta1, theta2 = anchor_point.psi1.value, -anchor_point.psi2.value
            else:
                theta1, theta2 = np.pi - anchor_point.psi1.value, np.pi + anchor_point.psi2.value
            x0, y0 = anchor_point.xy[0], anchor_point.xy[1]

            x_m1, y_m1 = self.g1_minus_points[anchor_point.name][0], self.g1_minus_points[anchor_point.name][1]
            g2_minus_point = np.zeros(2)
            g2_minus_point[0] = x_m1 - 1 / R * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3 / 2) / (
                    1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

            x_p1, y_p1 = self.g1_plus_points[anchor_point.name][0], self.g1_plus_points[anchor_point.name][1]
            g2_plus_point = np.zeros(2)
            g2_plus_point[0] = x_p1 - 1 / R * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3 / 2) / (
                    1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

            self.g2_minus_points[anchor_point.name] = g2_minus_point
            self.g2_plus_points[anchor_point.name] = g2_plus_point

        return self.g2_minus_points, self.g2_plus_points

    def extract_parameters(self):

        self.params = [var.value for var in vars(self.base_airfoil_params).values()
                       if isinstance(var, Param) and var.active and not var.linked]

        self.bounds = [[var.bounds[0], var.bounds[1]] for var in vars(self.base_airfoil_params).values()
                       if isinstance(var, Param) and var.active and not var.linked]

        for anchor_point in self.anchor_point_tuple:

            self.params.extend([var.value for var in vars(anchor_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

            self.bounds.extend([[var.bounds[0], var.bounds[1]] for var in vars(anchor_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

        for free_point in self.free_point_tuple:

            self.params.extend([var.value for var in vars(free_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

            self.bounds.extend([[var.bounds[0], var.bounds[1]] for var in vars(free_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

    def order_control_points(self):
        self.control_points = np.array([])
        for idx, anchor_point in enumerate(self.anchor_point_order):

            if idx == 0:
                self.control_points = np.append(self.control_points, self.anchor_points[anchor_point])
                self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
            else:
                if anchor_point in self.g2_minus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.g1_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.anchor_points[anchor_point]))
                if anchor_point in self.g1_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
                if anchor_point in self.g2_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_plus_points[anchor_point]))

            if anchor_point in self.free_points:
                if len(self.free_points[anchor_point]) &gt; 0:
                    for fp_idx in range(len(self.free_points[anchor_point])):
                        self.control_points = \
                            np.row_stack((self.control_points, self.free_points[anchor_point][fp_idx, :]))

        self.n_control_points = len(self.control_points)
        return self.control_points, self.n_control_points

    def add_free_point(self, free_point: FreePoint):
        &#34;&#34;&#34;
        Adds a free point (and 2 degrees of freedom) to a given Bezier curve (defined by the previous_anchor_point)
        :param free_point:
        :return:
        &#34;&#34;&#34;
        if free_point.previous_anchor_point not in self.free_points.keys():
            self.free_points[free_point.previous_anchor_point] = np.array([])
        if len(self.free_points[free_point.previous_anchor_point]) == 0:
            self.free_points[free_point.previous_anchor_point] = free_point.xy.reshape((1, 2))
        else:
            self.free_points[free_point.previous_anchor_point] = np.vstack(
                (self.free_points[free_point.previous_anchor_point], free_point.xy))

        # Increment the order of the modified Bézier curve
        self.N[free_point.previous_anchor_point] += 1
        self.needs_update = True

    def add_anchor_point(self, anchor_point: AnchorPoint):
        &#34;&#34;&#34;
        Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
        control point branch into the set of control points.
        :param anchor_point:
        :return:
        &#34;&#34;&#34;
        self.anchor_point_order.insert(self.anchor_point_order.index(anchor_point.previous_anchor_point) + 1,
                                       anchor_point.name)
        self.anchor_points[anchor_point.name] = anchor_point.xy
        self.set_slope(anchor_point)
        if self.anchor_point_order.index(anchor_point.name) &gt; self.anchor_point_order.index(&#39;le&#39;):
            self.N[&#39;le&#39;] = 5  # Set the order of the Bezier curve after the leading edge to 5
            self.N[self.anchor_point_order[-2]] = 4  # Set the order of the last Bezier curve to 4
        else:
            self.N[anchor_point.name] = 5  # Set the order of the Bezier curve after the anchor point to 5
        self.set_curvature(anchor_point)
        self.needs_update = True

    def add_anchor_points(self):
        for anchor_point in self.anchor_point_tuple:
            if anchor_point.name not in self.anchor_point_order:
                self.add_anchor_point(anchor_point)
        self.needs_update = True

    def add_free_points(self):
        for free_point in self.free_point_tuple:
            self.add_free_point(free_point)
        self.needs_update = True

    def update_anchor_point_array(self):
        for key in self.anchor_point_order:
            xy = self.anchor_points[key]
            if key == &#39;te_1&#39;:
                self.anchor_point_array = xy
            else:
                self.anchor_point_array = np.row_stack((self.anchor_point_array, xy))

    def update(self):
        self.add_anchor_points()
        self.add_free_points()
        self.extract_parameters()
        self.order_control_points()
        self.update_anchor_point_array()
        self.rotate(-self.alf.value)
        self.translate(self.dx.value, self.dy.value)
        self.generate_airfoil_coordinates()
        self.needs_update = False

    def override(self, parameters):
        self.__init__(self.nt, self.base_airfoil_params, self.anchor_point_tuple, self.free_point_tuple,
                      override_parameters=parameters)

    def translate(self, dx: float, dy: float):
        &#34;&#34;&#34;
        ### Description:

        Translates all the control points and anchor points by \\(\\Delta x\\) and \\(\\Delta y\\).

        ### Args:

        `dx`: \\(x\\)-direction translation magnitude

        `dy`: \\(y\\)-direction translation magnitude

        ### Returns:

        The translated control point and anchor point arrays
        &#34;&#34;&#34;
        self.control_points[:, 0] += dx
        self.control_points[:, 1] += dy
        self.anchor_point_array[:, 0] += dx
        self.anchor_point_array[:, 1] += dy
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def rotate(self, angle: float):
        &#34;&#34;&#34;
        ### Description:

        Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.

        ### Args:

        `angle`: Angle (in radians) by which to rotate the airfoil.

        ### Returns:

        The rotated control point and anchor point arrays
        &#34;&#34;&#34;
        rot_mat = np.array([[np.cos(angle), -np.sin(angle)],
                            [np.sin(angle), np.cos(angle)]])
        self.control_points = (rot_mat @ self.control_points.T).T
        self.anchor_point_array = (rot_mat @ self.anchor_point_array.T).T
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def generate_airfoil_coordinates(self):
        if self.C:
            self.C = []
        P_start_idx = 0
        for idx in range(len(self.anchor_point_order) - 1):
            P_length = self.N[self.anchor_point_order[idx]] + 1
            P_end_idx = P_start_idx + P_length
            P = self.control_points[P_start_idx:P_end_idx, :]
            C = bezier(P, self.nt)
            self.C.append(C)
            P_start_idx = P_end_idx - 1
        coords = np.array([])
        curvature = np.array([])
        for idx in range(len(self.C)):
            if idx == 0:
                coords = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;y&#39;]))
                curvature = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;k&#39;]))
            else:
                coords = np.row_stack((coords, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;y&#39;][1:]))))
                curvature = np.row_stack((curvature, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;k&#39;][1:]))))
        self.coords = coords
        self.curvature = curvature
        return self.coords, self.C

    def compute_area(self):
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        polygon = Polygon(points_shapely)
        area = polygon.area
        self.area = area
        return area

    def check_self_intersection(self):
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        line_string = LineString(points_shapely)
        is_simple = line_string.is_simple
        return not is_simple

    def plot(self, plot_what: typing.Tuple[str, ...], fig: Figure = None, axs: Axes = None, show_plot: bool = True,
             save_plot: bool = False, save_path: str = None, plot_kwargs: typing.List[dict] = None,
             show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5,
             tight_layout: bool = True, axis_equal: bool = True):
        if self.needs_update:
            self.update()
        if fig is None and axs is None:
            fig, axs = plt.subplots(1, 1)

        for what_to_plot in plot_what:

            if what_to_plot == &#39;airfoil&#39;:
                for idx, C in enumerate(self.C):
                    if plot_kwargs is None:
                        if idx == 0:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;, label=&#39;airfoil&#39;)
                        else:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;)
                    else:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], **plot_kwargs[idx])

            if what_to_plot == &#39;anchor-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], &#39;:x&#39;, color=&#39;black&#39;,
                             label=&#39;anchor point skeleton&#39;)
                else:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], **plot_kwargs)

            if what_to_plot == &#39;control-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], &#39;--*&#39;, color=&#39;grey&#39;,
                             label=&#39;control point skeleton&#39;)
                else:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], **plot_kwargs)
            if what_to_plot == &#39;chordline&#39;:
                if plot_kwargs is None:
                    axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                             np.array([0, -self.c.value * np.sin(self.alf.value)]), &#39;-.&#39;, color=&#39;indianred&#39;,
                             label=&#39;chordline&#39;)
                else:
                    axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                             np.array([0, -self.c.value * np.sin(self.alf.value)]), **plot_kwargs)
            if what_to_plot == &#39;R-circles&#39;:
                line = [[0, self.R_le.value * np.cos(self.phi_le.value - self.alf.value)],
                        [0, self.R_le.value * np.sin(self.phi_le.value - self.alf.value)]]
                circle = plt.Circle((line[0][1], line[1][1]), self.R_le.value, fill=False, color=&#39;gold&#39;,
                                    label=&#39;R circle&#39;)
                axs.plot(line[0], line[1], color=&#39;gold&#39;)
                axs.add_patch(circle)
            if what_to_plot == &#39;curvature&#39;:
                if plot_kwargs is None:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], color=&#39;cornflowerblue&#39;, label=&#39;curvature&#39;)
                else:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], **plot_kwargs)

        if axis_equal:
            axs.set_aspect(&#39;equal&#39;, &#39;box&#39;)
        if show_title:
            area = self.compute_area()
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$, $A={area:.5f}$&#39;)
        else:
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$&#39;)
        if tight_layout:
            fig.tight_layout()
        fig.set_figwidth(figwidth)
        fig.set_figheight(figheight)
        if show_legend:
            axs.legend()
        if save_plot:
            fig.savefig(save_path)
        if show_plot:
            plt.show()
        return fig, axs


def bezier(P: np.ndarray, nt: int) -&gt; dict:
    &#34;&#34;&#34;
    ### Description:

    Computes the Bézier curve through the control points `P` according to
    $$\\vec{C}(t)=\\sum_{i=0}^n \\vec{P}_i B_{i,n}(t)$$ where \\(B_{i,n}(t)\\) is the Bernstein polynomial, given by
    $$B_{i,n}={n \\choose i} t^i (1-t)^{n-i}$$

    Also included are first derivative, second derivative, and curvature information. These are given by
    $$\\vec{C}&#39;(t)=n \\sum_{i=0}^{n-1} (\\vec{P}_{i+1} - \\vec{P}_i B_{i,n-1}(t)$$
    $$\\vec{C}&#39;&#39;(t)=n(n-1) \\sum_{i=0}^{n-2} (\\vec{P}_{i+2}-2\\vec{P}_{i+1}+\\vec{P}_i) B_{i,n-2}(t)$$
    $$\\kappa(t)=\\frac{C&#39;_x(t) C&#39;&#39;_y(t) - C&#39;_y(t) C&#39;&#39;_x(t)}{[(C&#39;_x)^2(t) + (C&#39;_y)^2(t)]^{3/2}}$$

    An example cubic Bézier curve (order \\(n=3\\)) is shown below. Note that the curve passes through the first and
    last control points and has a local slope at \\(P_0\\) equal to the slope of the line passing through \\(P_0\\)
    and \\(P_1\\). Similarly, the local slope at \\(P_3\\) is equal to the slope of the line passing through
    \\(P_2\\) and \\(P_3\\). These properties of Bézier curves allow us to easily enforce \\(G^0\\) and \\(G^1\\)
    continuity at Bézier curve &#34;joints&#34; (common endpoints of connected Bézier curves).

    .. image:: bezier_curve.png

    ### Args:

    `P`: The control point `np.ndarray` of `shape=(n+1, 2)`, where `n` is the order of the Bézier curve and `n+1` is
    the number of control points in the Bézier curve. The two columns represent the \\(x\\)- and \\(y\\) -components of
    the control points.

    `nt`: number of points in the `t` vector (defines the resolution of the curve)

    ### Returns:

    A dictionary of `numpy` arrays of `shape=nt` containing information related to the created Bézier curve:

    $$C_x(t), C_y(t), C&#39;_x(t), C&#39;_y(t), C&#39;&#39;_x(t), C&#39;&#39;_y(t), \\kappa(t)$$
    where the \\(x\\) and \\(y\\) subscripts represent the \\(x\\) and \\(y\\) components of the vector-valued functions
    \\(\\vec{C}(t)\\), \\(\\vec{C}&#39;(t)\\), and \\(\\vec{C}&#39;&#39;(t)\\).
    &#34;&#34;&#34;

    def nCr(n_, r):
        &#34;&#34;&#34;
        ### Description:

        Simple function that computes the mathematical combination $$n \\choose r$$

        ### Args:

        `n_`: `n` written with a trailing underscore to avoid conflation with the order `n` of the Bézier curve

        `r&#39;

        ### Returns

        $$n \\choose r$$
        &#34;&#34;&#34;
        f = np.math.factorial
        return f(n_) / f(r) / f(n_ - r)

    t = np.linspace(0, 1, nt)
    C = {
        &#39;t&#39;: t,
        &#39;x&#39;: 0,
        &#39;y&#39;: 0,
        &#39;px&#39;: 0,
        &#39;py&#39;: 0,
        &#39;ppx&#39;: 0,
        &#39;ppy&#39;: 0
    }
    n = len(P)
    for i in range(n):
        # Calculate the x- and y-coordinates of the of the Bezier curve given the input vector t
        C[&#39;x&#39;] = C[&#39;x&#39;] + P[i, 0] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
        C[&#39;y&#39;] = C[&#39;y&#39;] + P[i, 1] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
    for i in range(n - 1):
        # Calculate the first derivatives of the Bezier curve with respect to t, that is C_x&#39;(t) and C_y&#39;(t). Here,
        # C_x&#39;(t) is the x-component of the vector derivative dC(t)/dt, and C_y&#39;(t) is the y-component
        C[&#39;px&#39;] = C[&#39;px&#39;] + (n - 1) * (P[i + 1, 0] - P[i, 0]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
        C[&#39;py&#39;] = C[&#39;py&#39;] + (n - 1) * (P[i + 1, 1] - P[i, 1]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
    for i in range(n - 2):
        # Calculate the second derivatives of the Bezier curve with respect to t, that is C_x&#39;&#39;(t) and C_y&#39;&#39;(t). Here,
        # C_x&#39;&#39;(t) is the x-component of the vector derivative d^2C(t)/dt^2, and C_y&#39;&#39;(t) is the y-component
        C[&#39;ppx&#39;] = C[&#39;ppx&#39;] + (n - 1) * (n - 2) * (P[i + 2, 0] - 2 * P[i + 1, 0] + P[i, 0]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)
        C[&#39;ppy&#39;] = C[&#39;ppy&#39;] + (n - 1) * (n - 2) * (P[i + 2, 1] - 2 * P[i + 1, 1] + P[i, 1]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)

        # Calculate the curvature of the Bezier curve (k = kappa = 1 / R, where R is the radius of curvature)
        C[&#39;k&#39;] = (C[&#39;px&#39;] * C[&#39;ppy&#39;] - C[&#39;py&#39;] * C[&#39;ppx&#39;]) / (C[&#39;px&#39;] ** 2 + C[&#39;py&#39;] ** 2) ** (3 / 2)

    return C


def main():

    base_airfoil_params = BaseAirfoilParams(c=Param(5.0),
                                            alf=Param(np.deg2rad(5.0)),
                                            R_le=Param(0.06, &#39;length&#39;),
                                            L_le=Param(0.08, &#39;length&#39;),
                                            r_le=Param(0.6),
                                            phi_le=Param(np.deg2rad(5.0)),
                                            psi1_le=Param(np.deg2rad(10.0)),
                                            psi2_le=Param(np.deg2rad(15.0)),
                                            L1_te=Param(0.25, &#39;length&#39;),
                                            L2_te=Param(0.3, &#39;length&#39;),
                                            theta1_te=Param(np.deg2rad(2.0)),
                                            theta2_te=Param(np.deg2rad(2.0)),
                                            t_te=Param(0.0, &#39;length&#39;),
                                            r_te=Param(0.5),
                                            phi_te=Param(np.deg2rad(0.0)),
                                            non_dim_by_chord=True
                                            )

    anchor_point1 = AnchorPoint(x=Param(0.55, units=&#39;length&#39;),
                                y=Param(0.05, units=&#39;length&#39;),
                                name=&#39;anchor-top&#39;,
                                previous_anchor_point=&#39;te_1&#39;,
                                L=Param(0.1, units=&#39;length&#39;),
                                R=Param(-0.3, units=&#39;length&#39;),
                                r=Param(0.5),
                                phi=Param(np.deg2rad(0.0)),
                                psi1=Param(np.deg2rad(45.0)),
                                psi2=Param(np.deg2rad(45.0)),
                                length_scale_dimension=base_airfoil_params.c.value
                                )

    anchor_point2 = AnchorPoint(x=Param(0.35, units=&#39;length&#39;),
                                y=Param(-0.02, units=&#39;length&#39;),
                                name=&#39;anchor-bottom&#39;,
                                previous_anchor_point=&#39;le&#39;,
                                L=Param(0.13, units=&#39;length&#39;),
                                R=Param(0.4, units=&#39;length&#39;),
                                r=Param(0.7),
                                phi=Param(np.deg2rad(0.0)),
                                psi1=Param(np.deg2rad(75.0)),
                                psi2=Param(np.deg2rad(75.0)),
                                length_scale_dimension=base_airfoil_params.c.value
                                )

    anchor_point_tuple = (anchor_point1, anchor_point2)

    free_point1 = FreePoint(x=Param(0.15, units=&#39;length&#39;),
                            y=Param(0.015, units=&#39;length&#39;),
                            previous_anchor_point=&#39;le&#39;,
                            length_scale_dimension=base_airfoil_params.c.value)

    free_point2 = FreePoint(x=Param(0.58, units=&#39;length&#39;),
                            y=Param(0.0, units=&#39;length&#39;),
                            previous_anchor_point=&#39;anchor-bottom&#39;,
                            length_scale_dimension=base_airfoil_params.c.value)

    free_point3 = FreePoint(x=Param(0.3, units=&#39;length&#39;),
                            y=Param(0.07, units=&#39;length&#39;),
                            previous_anchor_point=&#39;anchor-top&#39;,
                            length_scale_dimension=base_airfoil_params.c.value)

    free_point_tuple = (free_point1, free_point2, free_point3)

    airfoil = Airfoil(number_coordinates=100,
                      base_airfoil_params=base_airfoil_params,
                      anchor_point_tuple=anchor_point_tuple,
                      free_point_tuple=free_point_tuple)

    parameters = [5.0, 0.08726646259971647, 0.06, 0.08, 0.6, 0.08726646259971647, 0.17453292519943295,
                  0.2617993877991494, 0.25, 0.3, 0.03490658503988659, 0.03490658503988659, 0.0, 0.5, 0.0, 0.55, 0.05,
                  0.1, -0.3, 0.5, 0.0, 0.7853981633974483, 0.7853981633974483, 0.35, -0.02, 0.13, 0.4, 0.7, 0.0,
                  1.3089969389957472, 1.3089969389957472, 0.15, 0.015, 0.58, 0.0, 0.3, 0.07]

    # airfoil.override(parameters)

    self_intersecting = airfoil.check_self_intersection()
    print(f&#34;Self-intersecting? {self_intersecting}&#34;)

    airfoil.plot((&#39;airfoil&#39;, &#39;control-point-skeleton&#39;))


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyairpar.core.airfoil.bezier"><code class="name flex">
<span>def <span class="ident">bezier</span></span>(<span>P: numpy.ndarray, nt: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Computes the Bézier curve through the control points <code>P</code> according to
<span><span class="MathJax_Preview">\vec{C}(t)=\sum_{i=0}^n \vec{P}_i B_{i,n}(t)</span><script type="math/tex; mode=display">\vec{C}(t)=\sum_{i=0}^n \vec{P}_i B_{i,n}(t)</script></span> where <span><span class="MathJax_Preview">B_{i,n}(t)</span><script type="math/tex">B_{i,n}(t)</script></span> is the Bernstein polynomial, given by
<span><span class="MathJax_Preview">B_{i,n}={n \choose i} t^i (1-t)^{n-i}</span><script type="math/tex; mode=display">B_{i,n}={n \choose i} t^i (1-t)^{n-i}</script></span></p>
<p>Also included are first derivative, second derivative, and curvature information. These are given by
<span><span class="MathJax_Preview">\vec{C}'(t)=n \sum_{i=0}^{n-1} (\vec{P}_{i+1} - \vec{P}_i B_{i,n-1}(t)</span><script type="math/tex; mode=display">\vec{C}'(t)=n \sum_{i=0}^{n-1} (\vec{P}_{i+1} - \vec{P}_i B_{i,n-1}(t)</script></span>
<span><span class="MathJax_Preview">\vec{C}''(t)=n(n-1) \sum_{i=0}^{n-2} (\vec{P}_{i+2}-2\vec{P}_{i+1}+\vec{P}_i) B_{i,n-2}(t)</span><script type="math/tex; mode=display">\vec{C}''(t)=n(n-1) \sum_{i=0}^{n-2} (\vec{P}_{i+2}-2\vec{P}_{i+1}+\vec{P}_i) B_{i,n-2}(t)</script></span>
<span><span class="MathJax_Preview">\kappa(t)=\frac{C'_x(t) C''_y(t) - C'_y(t) C''_x(t)}{[(C'_x)^2(t) + (C'_y)^2(t)]^{3/2}}</span><script type="math/tex; mode=display">\kappa(t)=\frac{C'_x(t) C''_y(t) - C'_y(t) C''_x(t)}{[(C'_x)^2(t) + (C'_y)^2(t)]^{3/2}}</script></span></p>
<p>An example cubic Bézier curve (order <span><span class="MathJax_Preview">n=3</span><script type="math/tex">n=3</script></span>) is shown below. Note that the curve passes through the first and
last control points and has a local slope at <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> equal to the slope of the line passing through <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span>
and <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>. Similarly, the local slope at <span><span class="MathJax_Preview">P_3</span><script type="math/tex">P_3</script></span> is equal to the slope of the line passing through
<span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span> and <span><span class="MathJax_Preview">P_3</span><script type="math/tex">P_3</script></span>. These properties of Bézier curves allow us to easily enforce <span><span class="MathJax_Preview">G^0</span><script type="math/tex">G^0</script></span> and <span><span class="MathJax_Preview">G^1</span><script type="math/tex">G^1</script></span>
continuity at Bézier curve "joints" (common endpoints of connected Bézier curves).</p>
<p><img alt="" src="bezier_curve.png"></p>
<h3 id="args">Args:</h3>
<p><code>P</code>: The control point <code>np.ndarray</code> of <code>shape=(n+1, 2)</code>, where <code>n</code> is the order of the Bézier curve and <code>n+1</code> is
the number of control points in the Bézier curve. The two columns represent the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>- and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> -components of
the control points.</p>
<p><code>nt</code>: number of points in the <code>t</code> vector (defines the resolution of the curve)</p>
<h3 id="returns">Returns:</h3>
<p>A dictionary of <code>numpy</code> arrays of <code>shape=nt</code> containing information related to the created Bézier curve:</p>
<p><span><span class="MathJax_Preview">C_x(t), C_y(t), C'_x(t), C'_y(t), C''_x(t), C''_y(t), \kappa(t)</span><script type="math/tex; mode=display">C_x(t), C_y(t), C'_x(t), C'_y(t), C''_x(t), C''_y(t), \kappa(t)</script></span>
where the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> subscripts represent the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> components of the vector-valued functions
<span><span class="MathJax_Preview">\vec{C}(t)</span><script type="math/tex">\vec{C}(t)</script></span>, <span><span class="MathJax_Preview">\vec{C}'(t)</span><script type="math/tex">\vec{C}'(t)</script></span>, and <span><span class="MathJax_Preview">\vec{C}''(t)</span><script type="math/tex">\vec{C}''(t)</script></span>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bezier(P: np.ndarray, nt: int) -&gt; dict:
    &#34;&#34;&#34;
    ### Description:

    Computes the Bézier curve through the control points `P` according to
    $$\\vec{C}(t)=\\sum_{i=0}^n \\vec{P}_i B_{i,n}(t)$$ where \\(B_{i,n}(t)\\) is the Bernstein polynomial, given by
    $$B_{i,n}={n \\choose i} t^i (1-t)^{n-i}$$

    Also included are first derivative, second derivative, and curvature information. These are given by
    $$\\vec{C}&#39;(t)=n \\sum_{i=0}^{n-1} (\\vec{P}_{i+1} - \\vec{P}_i B_{i,n-1}(t)$$
    $$\\vec{C}&#39;&#39;(t)=n(n-1) \\sum_{i=0}^{n-2} (\\vec{P}_{i+2}-2\\vec{P}_{i+1}+\\vec{P}_i) B_{i,n-2}(t)$$
    $$\\kappa(t)=\\frac{C&#39;_x(t) C&#39;&#39;_y(t) - C&#39;_y(t) C&#39;&#39;_x(t)}{[(C&#39;_x)^2(t) + (C&#39;_y)^2(t)]^{3/2}}$$

    An example cubic Bézier curve (order \\(n=3\\)) is shown below. Note that the curve passes through the first and
    last control points and has a local slope at \\(P_0\\) equal to the slope of the line passing through \\(P_0\\)
    and \\(P_1\\). Similarly, the local slope at \\(P_3\\) is equal to the slope of the line passing through
    \\(P_2\\) and \\(P_3\\). These properties of Bézier curves allow us to easily enforce \\(G^0\\) and \\(G^1\\)
    continuity at Bézier curve &#34;joints&#34; (common endpoints of connected Bézier curves).

    .. image:: bezier_curve.png

    ### Args:

    `P`: The control point `np.ndarray` of `shape=(n+1, 2)`, where `n` is the order of the Bézier curve and `n+1` is
    the number of control points in the Bézier curve. The two columns represent the \\(x\\)- and \\(y\\) -components of
    the control points.

    `nt`: number of points in the `t` vector (defines the resolution of the curve)

    ### Returns:

    A dictionary of `numpy` arrays of `shape=nt` containing information related to the created Bézier curve:

    $$C_x(t), C_y(t), C&#39;_x(t), C&#39;_y(t), C&#39;&#39;_x(t), C&#39;&#39;_y(t), \\kappa(t)$$
    where the \\(x\\) and \\(y\\) subscripts represent the \\(x\\) and \\(y\\) components of the vector-valued functions
    \\(\\vec{C}(t)\\), \\(\\vec{C}&#39;(t)\\), and \\(\\vec{C}&#39;&#39;(t)\\).
    &#34;&#34;&#34;

    def nCr(n_, r):
        &#34;&#34;&#34;
        ### Description:

        Simple function that computes the mathematical combination $$n \\choose r$$

        ### Args:

        `n_`: `n` written with a trailing underscore to avoid conflation with the order `n` of the Bézier curve

        `r&#39;

        ### Returns

        $$n \\choose r$$
        &#34;&#34;&#34;
        f = np.math.factorial
        return f(n_) / f(r) / f(n_ - r)

    t = np.linspace(0, 1, nt)
    C = {
        &#39;t&#39;: t,
        &#39;x&#39;: 0,
        &#39;y&#39;: 0,
        &#39;px&#39;: 0,
        &#39;py&#39;: 0,
        &#39;ppx&#39;: 0,
        &#39;ppy&#39;: 0
    }
    n = len(P)
    for i in range(n):
        # Calculate the x- and y-coordinates of the of the Bezier curve given the input vector t
        C[&#39;x&#39;] = C[&#39;x&#39;] + P[i, 0] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
        C[&#39;y&#39;] = C[&#39;y&#39;] + P[i, 1] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
    for i in range(n - 1):
        # Calculate the first derivatives of the Bezier curve with respect to t, that is C_x&#39;(t) and C_y&#39;(t). Here,
        # C_x&#39;(t) is the x-component of the vector derivative dC(t)/dt, and C_y&#39;(t) is the y-component
        C[&#39;px&#39;] = C[&#39;px&#39;] + (n - 1) * (P[i + 1, 0] - P[i, 0]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
        C[&#39;py&#39;] = C[&#39;py&#39;] + (n - 1) * (P[i + 1, 1] - P[i, 1]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
    for i in range(n - 2):
        # Calculate the second derivatives of the Bezier curve with respect to t, that is C_x&#39;&#39;(t) and C_y&#39;&#39;(t). Here,
        # C_x&#39;&#39;(t) is the x-component of the vector derivative d^2C(t)/dt^2, and C_y&#39;&#39;(t) is the y-component
        C[&#39;ppx&#39;] = C[&#39;ppx&#39;] + (n - 1) * (n - 2) * (P[i + 2, 0] - 2 * P[i + 1, 0] + P[i, 0]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)
        C[&#39;ppy&#39;] = C[&#39;ppy&#39;] + (n - 1) * (n - 2) * (P[i + 2, 1] - 2 * P[i + 1, 1] + P[i, 1]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)

        # Calculate the curvature of the Bezier curve (k = kappa = 1 / R, where R is the radius of curvature)
        C[&#39;k&#39;] = (C[&#39;px&#39;] * C[&#39;ppy&#39;] - C[&#39;py&#39;] * C[&#39;ppx&#39;]) / (C[&#39;px&#39;] ** 2 + C[&#39;py&#39;] ** 2) ** (3 / 2)

    return C</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():

    base_airfoil_params = BaseAirfoilParams(c=Param(5.0),
                                            alf=Param(np.deg2rad(5.0)),
                                            R_le=Param(0.06, &#39;length&#39;),
                                            L_le=Param(0.08, &#39;length&#39;),
                                            r_le=Param(0.6),
                                            phi_le=Param(np.deg2rad(5.0)),
                                            psi1_le=Param(np.deg2rad(10.0)),
                                            psi2_le=Param(np.deg2rad(15.0)),
                                            L1_te=Param(0.25, &#39;length&#39;),
                                            L2_te=Param(0.3, &#39;length&#39;),
                                            theta1_te=Param(np.deg2rad(2.0)),
                                            theta2_te=Param(np.deg2rad(2.0)),
                                            t_te=Param(0.0, &#39;length&#39;),
                                            r_te=Param(0.5),
                                            phi_te=Param(np.deg2rad(0.0)),
                                            non_dim_by_chord=True
                                            )

    anchor_point1 = AnchorPoint(x=Param(0.55, units=&#39;length&#39;),
                                y=Param(0.05, units=&#39;length&#39;),
                                name=&#39;anchor-top&#39;,
                                previous_anchor_point=&#39;te_1&#39;,
                                L=Param(0.1, units=&#39;length&#39;),
                                R=Param(-0.3, units=&#39;length&#39;),
                                r=Param(0.5),
                                phi=Param(np.deg2rad(0.0)),
                                psi1=Param(np.deg2rad(45.0)),
                                psi2=Param(np.deg2rad(45.0)),
                                length_scale_dimension=base_airfoil_params.c.value
                                )

    anchor_point2 = AnchorPoint(x=Param(0.35, units=&#39;length&#39;),
                                y=Param(-0.02, units=&#39;length&#39;),
                                name=&#39;anchor-bottom&#39;,
                                previous_anchor_point=&#39;le&#39;,
                                L=Param(0.13, units=&#39;length&#39;),
                                R=Param(0.4, units=&#39;length&#39;),
                                r=Param(0.7),
                                phi=Param(np.deg2rad(0.0)),
                                psi1=Param(np.deg2rad(75.0)),
                                psi2=Param(np.deg2rad(75.0)),
                                length_scale_dimension=base_airfoil_params.c.value
                                )

    anchor_point_tuple = (anchor_point1, anchor_point2)

    free_point1 = FreePoint(x=Param(0.15, units=&#39;length&#39;),
                            y=Param(0.015, units=&#39;length&#39;),
                            previous_anchor_point=&#39;le&#39;,
                            length_scale_dimension=base_airfoil_params.c.value)

    free_point2 = FreePoint(x=Param(0.58, units=&#39;length&#39;),
                            y=Param(0.0, units=&#39;length&#39;),
                            previous_anchor_point=&#39;anchor-bottom&#39;,
                            length_scale_dimension=base_airfoil_params.c.value)

    free_point3 = FreePoint(x=Param(0.3, units=&#39;length&#39;),
                            y=Param(0.07, units=&#39;length&#39;),
                            previous_anchor_point=&#39;anchor-top&#39;,
                            length_scale_dimension=base_airfoil_params.c.value)

    free_point_tuple = (free_point1, free_point2, free_point3)

    airfoil = Airfoil(number_coordinates=100,
                      base_airfoil_params=base_airfoil_params,
                      anchor_point_tuple=anchor_point_tuple,
                      free_point_tuple=free_point_tuple)

    parameters = [5.0, 0.08726646259971647, 0.06, 0.08, 0.6, 0.08726646259971647, 0.17453292519943295,
                  0.2617993877991494, 0.25, 0.3, 0.03490658503988659, 0.03490658503988659, 0.0, 0.5, 0.0, 0.55, 0.05,
                  0.1, -0.3, 0.5, 0.0, 0.7853981633974483, 0.7853981633974483, 0.35, -0.02, 0.13, 0.4, 0.7, 0.0,
                  1.3089969389957472, 1.3089969389957472, 0.15, 0.015, 0.58, 0.0, 0.3, 0.07]

    # airfoil.override(parameters)

    self_intersecting = airfoil.check_self_intersection()
    print(f&#34;Self-intersecting? {self_intersecting}&#34;)

    airfoil.plot((&#39;airfoil&#39;, &#39;control-point-skeleton&#39;))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyairpar.core.airfoil.Airfoil"><code class="flex name class">
<span>class <span class="ident">Airfoil</span></span>
<span>(</span><span>number_coordinates: int = 100, base_airfoil_params: <a title="pyairpar.core.base_airfoil_params.BaseAirfoilParams" href="base_airfoil_params.html#pyairpar.core.base_airfoil_params.BaseAirfoilParams">BaseAirfoilParams</a> = &lt;pyairpar.core.base_airfoil_params.BaseAirfoilParams object&gt;, anchor_point_tuple: Tuple[<a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>, ...] = (), free_point_tuple: Tuple[<a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a>, ...] = (), override_parameters: list = None)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p><code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code> is the base class for Bézier-parametrized airfoil creation.</p>
<h3 id="args">Args:</h3>
<p><code>number_coordinates</code>: an <code>int</code> representing the number of discrete <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> - <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> coordinate pairs in each
Bézier curve. Gets passed to the <code><a title="pyairpar.core.airfoil.bezier" href="#pyairpar.core.airfoil.bezier">bezier()</a></code> function.</p>
<p><code>base_airfoil_params</code>: an instance of either the <code><a title="pyairpar.core.base_airfoil_params.BaseAirfoilParams" href="base_airfoil_params.html#pyairpar.core.base_airfoil_params.BaseAirfoilParams">BaseAirfoilParams</a></code> class or
the <code><a title="pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams" href="../symmetric/symmetric_base_airfoil_params.html#pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams">SymmetricBaseAirfoilParams</a></code> class which defines the base
set of parameters to be used</p>
<p><code>anchor_point_tuple</code>: a <code>tuple</code> of <code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code> objects. To specify a single
anchor point, use <code>(<a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>,)</code>. Default: <code>()</code></p>
<p><code>free_point_tuple</code>: a <code>tuple</code> of <code><a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a></code> objects. To specify a single free
point, use <code>(<a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a>,)</code>. Default: <code>()</code></p>
<h3 id="returns">Returns:</h3>
<p>An instance of the <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code> class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Airfoil:

    def __init__(self,
                 number_coordinates: int = 100,
                 base_airfoil_params: BaseAirfoilParams or SymmetricBaseAirfoilParams = BaseAirfoilParams(),
                 anchor_point_tuple: typing.Tuple[AnchorPoint, ...] = (),
                 free_point_tuple: typing.Tuple[FreePoint, ...] = (),
                 override_parameters: list = None
                 ):
        &#34;&#34;&#34;
        ### Description:

        `pyairpar.core.airfoil.Airfoil` is the base class for Bézier-parametrized airfoil creation.

        ### Args:

        `number_coordinates`: an `int` representing the number of discrete \\(x\\) - \\(y\\) coordinate pairs in each
        Bézier curve. Gets passed to the `bezier` function.

        `base_airfoil_params`: an instance of either the `pyairpar.core.base_airfoil_params.BaseAirfoilParams` class or
        the `pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams` class which defines the base
        set of parameters to be used

        `anchor_point_tuple`: a `tuple` of `pyairpar.core.anchor_point.AnchorPoint` objects. To specify a single
        anchor point, use `(pyairpar.core.anchor_point.AnchorPoint(),)`. Default: `()`

        `free_point_tuple`: a `tuple` of `pyairpar.core.free_point.FreePoint` objects. To specify a single free
        point, use `(pyairpar.core.free_point.FreePoint(),)`. Default: `()`

        ### Returns:

        An instance of the `Airfoil` class
        &#34;&#34;&#34;

        self.nt = number_coordinates
        self.params = []
        self.bounds = []
        self.base_airfoil_params = base_airfoil_params
        self.override_parameters = override_parameters

        self.override_parameter_start_idx = 0
        self.override_parameter_end_idx = self.base_airfoil_params.n_overrideable_parameters
        if self.override_parameters is not None:
            self.base_airfoil_params.override(
                self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
        self.override_parameter_start_idx += self.base_airfoil_params.n_overrideable_parameters

        self.c = base_airfoil_params.c
        self.alf = base_airfoil_params.alf
        self.R_le = base_airfoil_params.R_le
        self.L_le = base_airfoil_params.L_le
        self.r_le = base_airfoil_params.r_le
        self.phi_le = base_airfoil_params.phi_le
        self.psi1_le = base_airfoil_params.psi1_le
        self.psi2_le = base_airfoil_params.psi2_le
        self.L1_te = base_airfoil_params.L1_te
        self.L2_te = base_airfoil_params.L2_te
        self.theta1_te = base_airfoil_params.theta1_te
        self.theta2_te = base_airfoil_params.theta2_te
        self.t_te = base_airfoil_params.t_te
        self.r_te = base_airfoil_params.r_te
        self.phi_te = base_airfoil_params.phi_te
        self.dx = base_airfoil_params.dx
        self.dy = base_airfoil_params.dy

        # Ensure that all the trailing edge parameters are no longer active if the trailing edge thickness is set to 0.0
        if self.t_te.value == 0.0:
            self.r_te.active = False
            self.phi_te.active = False

        self.C = []
        self.free_points = {}
        self.param_dicts = {}
        self.coords = None
        self.curvature = None
        self.area = None
        self.needs_update = True

        self.anchor_point_tuple = anchor_point_tuple

        if self.override_parameters is not None:
            for anchor_point in self.anchor_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    anchor_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  anchor_point.n_overrideable_parameters
                anchor_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += anchor_point.n_overrideable_parameters

        self.free_point_tuple = free_point_tuple

        if self.override_parameters is not None:
            for free_point in self.free_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    free_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  free_point.n_overrideable_parameters
                free_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += free_point.n_overrideable_parameters

        self.anchor_points = {&#39;te_1&#39;: self.c.value * np.array([1, 0]) + self.r_te.value * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)]),
                              &#39;le&#39;: np.array([0.0, 0.0]),
                              &#39;te_2&#39;: self.c.value * np.array([1, 0]) -
                                      (1 - self.r_te.value) * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)])}
        self.anchor_point_order = [&#39;te_1&#39;, &#39;le&#39;, &#39;te_2&#39;]
        self.anchor_point_array = np.array([])

        self.N = {
            &#39;te_1&#39;: 4,
            &#39;le&#39;: 4
        }

        self.control_points = np.array([])
        self.n_control_points = len(self.control_points)

        self.g1_minus_points, self.g1_plus_points = self.init_g1_points()
        self.g2_minus_points, self.g2_plus_points = self.init_g2_points()

        self.update()

    def init_g1_points(self):

        g1_minus_points = {
            &#39;te_2&#39;: self.anchor_points[&#39;te_2&#39;] +
                  self.L2_te.value * np.array([-np.cos(self.theta2_te.value),
                                               -np.sin(self.theta2_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] +
                  self.r_le.value * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        g1_plus_points = {
            &#39;te_1&#39;: self.anchor_points[&#39;te_1&#39;] +
                    self.L1_te.value * np.array([-np.cos(self.theta1_te.value),
                                                 np.sin(self.theta1_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] -
                  (1 - self.r_le.value) * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        return g1_minus_points, g1_plus_points

    def init_g2_points(self):
        g2_minus_point_le, g2_plus_point_le = self.set_curvature_le()

        g2_minus_points = {
            &#39;le&#39;: g2_minus_point_le
        }

        g2_plus_points = {
            &#39;le&#39;: g2_plus_point_le
        }

        return g2_minus_points, g2_plus_points

    def set_slope(self, anchor_point: AnchorPoint):
        phi = anchor_point.phi.value
        r = anchor_point.r.value
        L = anchor_point.L.value

        if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + r * L * np.array([np.cos(phi), np.sin(phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
        else:
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(phi), np.sin(phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
        return self.g1_minus_points, self.g1_plus_points

    def set_curvature_le(self):
        if self.R_le.value == np.inf:
            g2_minus_point = self.g1_minus_points[&#39;le&#39;]
            g2_plus_point = self.g1_plus_points[&#39;le&#39;]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(&#39;le&#39;) - 1]], self.N[&#39;le&#39;]
            theta1, theta2 = self.psi1_le.value, -self.psi2_le.value
            x0, y0 = self.anchor_points[&#39;le&#39;][0], self.anchor_points[&#39;le&#39;][1]

            x_m1, y_m1 = self.g1_minus_points[&#39;le&#39;][0], self.g1_minus_points[&#39;le&#39;][1]
            g2_minus_point = np.zeros(2)
            g2_minus_point[0] = x_m1 - 1 / self.R_le.value * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3/2) / (
                                1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

            x_p1, y_p1 = self.g1_plus_points[&#39;le&#39;][0], self.g1_plus_points[&#39;le&#39;][1]
            g2_plus_point = np.zeros(2)
            g2_plus_point[0] = x_p1 - 1 / self.R_le.value * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3/2) / (
                               1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

        return g2_minus_point, g2_plus_point

    def set_curvature(self, anchor_point: AnchorPoint):
        R = anchor_point.R.value
        if R == np.inf:
            self.g2_minus_points[anchor_point.name] = self.g1_minus_points[anchor_point.name]
            self.g2_plus_points[anchor_point.name] = self.g1_plus_points[anchor_point.name]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(anchor_point.name) - 1]], \
                     self.N[anchor_point.name]
            if R &gt; 0:
                theta1, theta2 = anchor_point.psi1.value, -anchor_point.psi2.value
            else:
                theta1, theta2 = np.pi - anchor_point.psi1.value, np.pi + anchor_point.psi2.value
            x0, y0 = anchor_point.xy[0], anchor_point.xy[1]

            x_m1, y_m1 = self.g1_minus_points[anchor_point.name][0], self.g1_minus_points[anchor_point.name][1]
            g2_minus_point = np.zeros(2)
            g2_minus_point[0] = x_m1 - 1 / R * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3 / 2) / (
                    1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

            x_p1, y_p1 = self.g1_plus_points[anchor_point.name][0], self.g1_plus_points[anchor_point.name][1]
            g2_plus_point = np.zeros(2)
            g2_plus_point[0] = x_p1 - 1 / R * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3 / 2) / (
                    1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

            self.g2_minus_points[anchor_point.name] = g2_minus_point
            self.g2_plus_points[anchor_point.name] = g2_plus_point

        return self.g2_minus_points, self.g2_plus_points

    def extract_parameters(self):

        self.params = [var.value for var in vars(self.base_airfoil_params).values()
                       if isinstance(var, Param) and var.active and not var.linked]

        self.bounds = [[var.bounds[0], var.bounds[1]] for var in vars(self.base_airfoil_params).values()
                       if isinstance(var, Param) and var.active and not var.linked]

        for anchor_point in self.anchor_point_tuple:

            self.params.extend([var.value for var in vars(anchor_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

            self.bounds.extend([[var.bounds[0], var.bounds[1]] for var in vars(anchor_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

        for free_point in self.free_point_tuple:

            self.params.extend([var.value for var in vars(free_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

            self.bounds.extend([[var.bounds[0], var.bounds[1]] for var in vars(free_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

    def order_control_points(self):
        self.control_points = np.array([])
        for idx, anchor_point in enumerate(self.anchor_point_order):

            if idx == 0:
                self.control_points = np.append(self.control_points, self.anchor_points[anchor_point])
                self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
            else:
                if anchor_point in self.g2_minus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.g1_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.anchor_points[anchor_point]))
                if anchor_point in self.g1_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
                if anchor_point in self.g2_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_plus_points[anchor_point]))

            if anchor_point in self.free_points:
                if len(self.free_points[anchor_point]) &gt; 0:
                    for fp_idx in range(len(self.free_points[anchor_point])):
                        self.control_points = \
                            np.row_stack((self.control_points, self.free_points[anchor_point][fp_idx, :]))

        self.n_control_points = len(self.control_points)
        return self.control_points, self.n_control_points

    def add_free_point(self, free_point: FreePoint):
        &#34;&#34;&#34;
        Adds a free point (and 2 degrees of freedom) to a given Bezier curve (defined by the previous_anchor_point)
        :param free_point:
        :return:
        &#34;&#34;&#34;
        if free_point.previous_anchor_point not in self.free_points.keys():
            self.free_points[free_point.previous_anchor_point] = np.array([])
        if len(self.free_points[free_point.previous_anchor_point]) == 0:
            self.free_points[free_point.previous_anchor_point] = free_point.xy.reshape((1, 2))
        else:
            self.free_points[free_point.previous_anchor_point] = np.vstack(
                (self.free_points[free_point.previous_anchor_point], free_point.xy))

        # Increment the order of the modified Bézier curve
        self.N[free_point.previous_anchor_point] += 1
        self.needs_update = True

    def add_anchor_point(self, anchor_point: AnchorPoint):
        &#34;&#34;&#34;
        Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
        control point branch into the set of control points.
        :param anchor_point:
        :return:
        &#34;&#34;&#34;
        self.anchor_point_order.insert(self.anchor_point_order.index(anchor_point.previous_anchor_point) + 1,
                                       anchor_point.name)
        self.anchor_points[anchor_point.name] = anchor_point.xy
        self.set_slope(anchor_point)
        if self.anchor_point_order.index(anchor_point.name) &gt; self.anchor_point_order.index(&#39;le&#39;):
            self.N[&#39;le&#39;] = 5  # Set the order of the Bezier curve after the leading edge to 5
            self.N[self.anchor_point_order[-2]] = 4  # Set the order of the last Bezier curve to 4
        else:
            self.N[anchor_point.name] = 5  # Set the order of the Bezier curve after the anchor point to 5
        self.set_curvature(anchor_point)
        self.needs_update = True

    def add_anchor_points(self):
        for anchor_point in self.anchor_point_tuple:
            if anchor_point.name not in self.anchor_point_order:
                self.add_anchor_point(anchor_point)
        self.needs_update = True

    def add_free_points(self):
        for free_point in self.free_point_tuple:
            self.add_free_point(free_point)
        self.needs_update = True

    def update_anchor_point_array(self):
        for key in self.anchor_point_order:
            xy = self.anchor_points[key]
            if key == &#39;te_1&#39;:
                self.anchor_point_array = xy
            else:
                self.anchor_point_array = np.row_stack((self.anchor_point_array, xy))

    def update(self):
        self.add_anchor_points()
        self.add_free_points()
        self.extract_parameters()
        self.order_control_points()
        self.update_anchor_point_array()
        self.rotate(-self.alf.value)
        self.translate(self.dx.value, self.dy.value)
        self.generate_airfoil_coordinates()
        self.needs_update = False

    def override(self, parameters):
        self.__init__(self.nt, self.base_airfoil_params, self.anchor_point_tuple, self.free_point_tuple,
                      override_parameters=parameters)

    def translate(self, dx: float, dy: float):
        &#34;&#34;&#34;
        ### Description:

        Translates all the control points and anchor points by \\(\\Delta x\\) and \\(\\Delta y\\).

        ### Args:

        `dx`: \\(x\\)-direction translation magnitude

        `dy`: \\(y\\)-direction translation magnitude

        ### Returns:

        The translated control point and anchor point arrays
        &#34;&#34;&#34;
        self.control_points[:, 0] += dx
        self.control_points[:, 1] += dy
        self.anchor_point_array[:, 0] += dx
        self.anchor_point_array[:, 1] += dy
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def rotate(self, angle: float):
        &#34;&#34;&#34;
        ### Description:

        Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.

        ### Args:

        `angle`: Angle (in radians) by which to rotate the airfoil.

        ### Returns:

        The rotated control point and anchor point arrays
        &#34;&#34;&#34;
        rot_mat = np.array([[np.cos(angle), -np.sin(angle)],
                            [np.sin(angle), np.cos(angle)]])
        self.control_points = (rot_mat @ self.control_points.T).T
        self.anchor_point_array = (rot_mat @ self.anchor_point_array.T).T
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def generate_airfoil_coordinates(self):
        if self.C:
            self.C = []
        P_start_idx = 0
        for idx in range(len(self.anchor_point_order) - 1):
            P_length = self.N[self.anchor_point_order[idx]] + 1
            P_end_idx = P_start_idx + P_length
            P = self.control_points[P_start_idx:P_end_idx, :]
            C = bezier(P, self.nt)
            self.C.append(C)
            P_start_idx = P_end_idx - 1
        coords = np.array([])
        curvature = np.array([])
        for idx in range(len(self.C)):
            if idx == 0:
                coords = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;y&#39;]))
                curvature = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;k&#39;]))
            else:
                coords = np.row_stack((coords, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;y&#39;][1:]))))
                curvature = np.row_stack((curvature, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;k&#39;][1:]))))
        self.coords = coords
        self.curvature = curvature
        return self.coords, self.C

    def compute_area(self):
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        polygon = Polygon(points_shapely)
        area = polygon.area
        self.area = area
        return area

    def check_self_intersection(self):
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        line_string = LineString(points_shapely)
        is_simple = line_string.is_simple
        return not is_simple

    def plot(self, plot_what: typing.Tuple[str, ...], fig: Figure = None, axs: Axes = None, show_plot: bool = True,
             save_plot: bool = False, save_path: str = None, plot_kwargs: typing.List[dict] = None,
             show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5,
             tight_layout: bool = True, axis_equal: bool = True):
        if self.needs_update:
            self.update()
        if fig is None and axs is None:
            fig, axs = plt.subplots(1, 1)

        for what_to_plot in plot_what:

            if what_to_plot == &#39;airfoil&#39;:
                for idx, C in enumerate(self.C):
                    if plot_kwargs is None:
                        if idx == 0:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;, label=&#39;airfoil&#39;)
                        else:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;)
                    else:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], **plot_kwargs[idx])

            if what_to_plot == &#39;anchor-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], &#39;:x&#39;, color=&#39;black&#39;,
                             label=&#39;anchor point skeleton&#39;)
                else:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], **plot_kwargs)

            if what_to_plot == &#39;control-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], &#39;--*&#39;, color=&#39;grey&#39;,
                             label=&#39;control point skeleton&#39;)
                else:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], **plot_kwargs)
            if what_to_plot == &#39;chordline&#39;:
                if plot_kwargs is None:
                    axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                             np.array([0, -self.c.value * np.sin(self.alf.value)]), &#39;-.&#39;, color=&#39;indianred&#39;,
                             label=&#39;chordline&#39;)
                else:
                    axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                             np.array([0, -self.c.value * np.sin(self.alf.value)]), **plot_kwargs)
            if what_to_plot == &#39;R-circles&#39;:
                line = [[0, self.R_le.value * np.cos(self.phi_le.value - self.alf.value)],
                        [0, self.R_le.value * np.sin(self.phi_le.value - self.alf.value)]]
                circle = plt.Circle((line[0][1], line[1][1]), self.R_le.value, fill=False, color=&#39;gold&#39;,
                                    label=&#39;R circle&#39;)
                axs.plot(line[0], line[1], color=&#39;gold&#39;)
                axs.add_patch(circle)
            if what_to_plot == &#39;curvature&#39;:
                if plot_kwargs is None:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], color=&#39;cornflowerblue&#39;, label=&#39;curvature&#39;)
                else:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], **plot_kwargs)

        if axis_equal:
            axs.set_aspect(&#39;equal&#39;, &#39;box&#39;)
        if show_title:
            area = self.compute_area()
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$, $A={area:.5f}$&#39;)
        else:
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$&#39;)
        if tight_layout:
            fig.tight_layout()
        fig.set_figwidth(figwidth)
        fig.set_figheight(figheight)
        if show_legend:
            axs.legend()
        if save_plot:
            fig.savefig(save_path)
        if show_plot:
            plt.show()
        return fig, axs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyairpar.symmetric.symmetric_airfoil.SymmetricAirfoil" href="../symmetric/symmetric_airfoil.html#pyairpar.symmetric.symmetric_airfoil.SymmetricAirfoil">SymmetricAirfoil</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyairpar.core.airfoil.Airfoil.add_anchor_point"><code class="name flex">
<span>def <span class="ident">add_anchor_point</span></span>(<span>self, anchor_point: <a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
control point branch into the set of control points.
:param anchor_point:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_anchor_point(self, anchor_point: AnchorPoint):
    &#34;&#34;&#34;
    Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
    control point branch into the set of control points.
    :param anchor_point:
    :return:
    &#34;&#34;&#34;
    self.anchor_point_order.insert(self.anchor_point_order.index(anchor_point.previous_anchor_point) + 1,
                                   anchor_point.name)
    self.anchor_points[anchor_point.name] = anchor_point.xy
    self.set_slope(anchor_point)
    if self.anchor_point_order.index(anchor_point.name) &gt; self.anchor_point_order.index(&#39;le&#39;):
        self.N[&#39;le&#39;] = 5  # Set the order of the Bezier curve after the leading edge to 5
        self.N[self.anchor_point_order[-2]] = 4  # Set the order of the last Bezier curve to 4
    else:
        self.N[anchor_point.name] = 5  # Set the order of the Bezier curve after the anchor point to 5
    self.set_curvature(anchor_point)
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.add_anchor_points"><code class="name flex">
<span>def <span class="ident">add_anchor_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_anchor_points(self):
    for anchor_point in self.anchor_point_tuple:
        if anchor_point.name not in self.anchor_point_order:
            self.add_anchor_point(anchor_point)
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.add_free_point"><code class="name flex">
<span>def <span class="ident">add_free_point</span></span>(<span>self, free_point: <a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a free point (and 2 degrees of freedom) to a given Bezier curve (defined by the previous_anchor_point)
:param free_point:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_free_point(self, free_point: FreePoint):
    &#34;&#34;&#34;
    Adds a free point (and 2 degrees of freedom) to a given Bezier curve (defined by the previous_anchor_point)
    :param free_point:
    :return:
    &#34;&#34;&#34;
    if free_point.previous_anchor_point not in self.free_points.keys():
        self.free_points[free_point.previous_anchor_point] = np.array([])
    if len(self.free_points[free_point.previous_anchor_point]) == 0:
        self.free_points[free_point.previous_anchor_point] = free_point.xy.reshape((1, 2))
    else:
        self.free_points[free_point.previous_anchor_point] = np.vstack(
            (self.free_points[free_point.previous_anchor_point], free_point.xy))

    # Increment the order of the modified Bézier curve
    self.N[free_point.previous_anchor_point] += 1
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.add_free_points"><code class="name flex">
<span>def <span class="ident">add_free_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_free_points(self):
    for free_point in self.free_point_tuple:
        self.add_free_point(free_point)
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.check_self_intersection"><code class="name flex">
<span>def <span class="ident">check_self_intersection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_self_intersection(self):
    if self.needs_update:
        self.update()
    points_shapely = list(map(tuple, self.coords))
    line_string = LineString(points_shapely)
    is_simple = line_string.is_simple
    return not is_simple</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.compute_area"><code class="name flex">
<span>def <span class="ident">compute_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_area(self):
    if self.needs_update:
        self.update()
    points_shapely = list(map(tuple, self.coords))
    polygon = Polygon(points_shapely)
    area = polygon.area
    self.area = area
    return area</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.extract_parameters"><code class="name flex">
<span>def <span class="ident">extract_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_parameters(self):

    self.params = [var.value for var in vars(self.base_airfoil_params).values()
                   if isinstance(var, Param) and var.active and not var.linked]

    self.bounds = [[var.bounds[0], var.bounds[1]] for var in vars(self.base_airfoil_params).values()
                   if isinstance(var, Param) and var.active and not var.linked]

    for anchor_point in self.anchor_point_tuple:

        self.params.extend([var.value for var in vars(anchor_point).values()
                            if isinstance(var, Param) and var.active and not var.linked])

        self.bounds.extend([[var.bounds[0], var.bounds[1]] for var in vars(anchor_point).values()
                            if isinstance(var, Param) and var.active and not var.linked])

    for free_point in self.free_point_tuple:

        self.params.extend([var.value for var in vars(free_point).values()
                            if isinstance(var, Param) and var.active and not var.linked])

        self.bounds.extend([[var.bounds[0], var.bounds[1]] for var in vars(free_point).values()
                            if isinstance(var, Param) and var.active and not var.linked])</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.generate_airfoil_coordinates"><code class="name flex">
<span>def <span class="ident">generate_airfoil_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_airfoil_coordinates(self):
    if self.C:
        self.C = []
    P_start_idx = 0
    for idx in range(len(self.anchor_point_order) - 1):
        P_length = self.N[self.anchor_point_order[idx]] + 1
        P_end_idx = P_start_idx + P_length
        P = self.control_points[P_start_idx:P_end_idx, :]
        C = bezier(P, self.nt)
        self.C.append(C)
        P_start_idx = P_end_idx - 1
    coords = np.array([])
    curvature = np.array([])
    for idx in range(len(self.C)):
        if idx == 0:
            coords = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;y&#39;]))
            curvature = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;k&#39;]))
        else:
            coords = np.row_stack((coords, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;y&#39;][1:]))))
            curvature = np.row_stack((curvature, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;k&#39;][1:]))))
    self.coords = coords
    self.curvature = curvature
    return self.coords, self.C</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.init_g1_points"><code class="name flex">
<span>def <span class="ident">init_g1_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_g1_points(self):

    g1_minus_points = {
        &#39;te_2&#39;: self.anchor_points[&#39;te_2&#39;] +
              self.L2_te.value * np.array([-np.cos(self.theta2_te.value),
                                           -np.sin(self.theta2_te.value)]),
        &#39;le&#39;: self.anchor_points[&#39;le&#39;] +
              self.r_le.value * self.L_le.value *
              np.array([np.cos(np.pi / 2 + self.phi_le.value),
                        np.sin(np.pi / 2 + self.phi_le.value)])
    }

    g1_plus_points = {
        &#39;te_1&#39;: self.anchor_points[&#39;te_1&#39;] +
                self.L1_te.value * np.array([-np.cos(self.theta1_te.value),
                                             np.sin(self.theta1_te.value)]),
        &#39;le&#39;: self.anchor_points[&#39;le&#39;] -
              (1 - self.r_le.value) * self.L_le.value *
              np.array([np.cos(np.pi / 2 + self.phi_le.value),
                        np.sin(np.pi / 2 + self.phi_le.value)])
    }

    return g1_minus_points, g1_plus_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.init_g2_points"><code class="name flex">
<span>def <span class="ident">init_g2_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_g2_points(self):
    g2_minus_point_le, g2_plus_point_le = self.set_curvature_le()

    g2_minus_points = {
        &#39;le&#39;: g2_minus_point_le
    }

    g2_plus_points = {
        &#39;le&#39;: g2_plus_point_le
    }

    return g2_minus_points, g2_plus_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.order_control_points"><code class="name flex">
<span>def <span class="ident">order_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_control_points(self):
    self.control_points = np.array([])
    for idx, anchor_point in enumerate(self.anchor_point_order):

        if idx == 0:
            self.control_points = np.append(self.control_points, self.anchor_points[anchor_point])
            self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
        else:
            if anchor_point in self.g2_minus_points:
                self.control_points = np.row_stack((self.control_points, self.g2_minus_points[anchor_point]))
            self.control_points = np.row_stack((self.control_points, self.g1_minus_points[anchor_point]))
            self.control_points = np.row_stack((self.control_points, self.anchor_points[anchor_point]))
            if anchor_point in self.g1_plus_points:
                self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
            if anchor_point in self.g2_plus_points:
                self.control_points = np.row_stack((self.control_points, self.g2_plus_points[anchor_point]))

        if anchor_point in self.free_points:
            if len(self.free_points[anchor_point]) &gt; 0:
                for fp_idx in range(len(self.free_points[anchor_point])):
                    self.control_points = \
                        np.row_stack((self.control_points, self.free_points[anchor_point][fp_idx, :]))

    self.n_control_points = len(self.control_points)
    return self.control_points, self.n_control_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.override"><code class="name flex">
<span>def <span class="ident">override</span></span>(<span>self, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override(self, parameters):
    self.__init__(self.nt, self.base_airfoil_params, self.anchor_point_tuple, self.free_point_tuple,
                  override_parameters=parameters)</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot_what: Tuple[str, ...], fig: matplotlib.figure.Figure = None, axs: matplotlib.axes._axes.Axes = None, show_plot: bool = True, save_plot: bool = False, save_path: str = None, plot_kwargs: List[dict] = None, show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5, tight_layout: bool = True, axis_equal: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, plot_what: typing.Tuple[str, ...], fig: Figure = None, axs: Axes = None, show_plot: bool = True,
         save_plot: bool = False, save_path: str = None, plot_kwargs: typing.List[dict] = None,
         show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5,
         tight_layout: bool = True, axis_equal: bool = True):
    if self.needs_update:
        self.update()
    if fig is None and axs is None:
        fig, axs = plt.subplots(1, 1)

    for what_to_plot in plot_what:

        if what_to_plot == &#39;airfoil&#39;:
            for idx, C in enumerate(self.C):
                if plot_kwargs is None:
                    if idx == 0:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;, label=&#39;airfoil&#39;)
                    else:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;)
                else:
                    axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], **plot_kwargs[idx])

        if what_to_plot == &#39;anchor-point-skeleton&#39;:
            if plot_kwargs is None:
                axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], &#39;:x&#39;, color=&#39;black&#39;,
                         label=&#39;anchor point skeleton&#39;)
            else:
                axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], **plot_kwargs)

        if what_to_plot == &#39;control-point-skeleton&#39;:
            if plot_kwargs is None:
                axs.plot(self.control_points[:, 0], self.control_points[:, 1], &#39;--*&#39;, color=&#39;grey&#39;,
                         label=&#39;control point skeleton&#39;)
            else:
                axs.plot(self.control_points[:, 0], self.control_points[:, 1], **plot_kwargs)
        if what_to_plot == &#39;chordline&#39;:
            if plot_kwargs is None:
                axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                         np.array([0, -self.c.value * np.sin(self.alf.value)]), &#39;-.&#39;, color=&#39;indianred&#39;,
                         label=&#39;chordline&#39;)
            else:
                axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                         np.array([0, -self.c.value * np.sin(self.alf.value)]), **plot_kwargs)
        if what_to_plot == &#39;R-circles&#39;:
            line = [[0, self.R_le.value * np.cos(self.phi_le.value - self.alf.value)],
                    [0, self.R_le.value * np.sin(self.phi_le.value - self.alf.value)]]
            circle = plt.Circle((line[0][1], line[1][1]), self.R_le.value, fill=False, color=&#39;gold&#39;,
                                label=&#39;R circle&#39;)
            axs.plot(line[0], line[1], color=&#39;gold&#39;)
            axs.add_patch(circle)
        if what_to_plot == &#39;curvature&#39;:
            if plot_kwargs is None:
                axs.plot(self.curvature[:, 0], self.curvature[:, 1], color=&#39;cornflowerblue&#39;, label=&#39;curvature&#39;)
            else:
                axs.plot(self.curvature[:, 0], self.curvature[:, 1], **plot_kwargs)

    if axis_equal:
        axs.set_aspect(&#39;equal&#39;, &#39;box&#39;)
    if show_title:
        area = self.compute_area()
        fig.suptitle(
            fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$, $A={area:.5f}$&#39;)
    else:
        fig.suptitle(
            fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$&#39;)
    if tight_layout:
        fig.tight_layout()
    fig.set_figwidth(figwidth)
    fig.set_figheight(figheight)
    if show_legend:
        axs.legend()
    if save_plot:
        fig.savefig(save_path)
    if show_plot:
        plt.show()
    return fig, axs</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.</p>
<h3 id="args">Args:</h3>
<p><code>angle</code>: Angle (in radians) by which to rotate the airfoil.</p>
<h3 id="returns">Returns:</h3>
<p>The rotated control point and anchor point arrays</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle: float):
    &#34;&#34;&#34;
    ### Description:

    Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.

    ### Args:

    `angle`: Angle (in radians) by which to rotate the airfoil.

    ### Returns:

    The rotated control point and anchor point arrays
    &#34;&#34;&#34;
    rot_mat = np.array([[np.cos(angle), -np.sin(angle)],
                        [np.sin(angle), np.cos(angle)]])
    self.control_points = (rot_mat @ self.control_points.T).T
    self.anchor_point_array = (rot_mat @ self.anchor_point_array.T).T
    self.needs_update = True
    return self.control_points, self.anchor_point_array</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_curvature"><code class="name flex">
<span>def <span class="ident">set_curvature</span></span>(<span>self, anchor_point: <a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curvature(self, anchor_point: AnchorPoint):
    R = anchor_point.R.value
    if R == np.inf:
        self.g2_minus_points[anchor_point.name] = self.g1_minus_points[anchor_point.name]
        self.g2_plus_points[anchor_point.name] = self.g1_plus_points[anchor_point.name]
    else:
        n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(anchor_point.name) - 1]], \
                 self.N[anchor_point.name]
        if R &gt; 0:
            theta1, theta2 = anchor_point.psi1.value, -anchor_point.psi2.value
        else:
            theta1, theta2 = np.pi - anchor_point.psi1.value, np.pi + anchor_point.psi2.value
        x0, y0 = anchor_point.xy[0], anchor_point.xy[1]

        x_m1, y_m1 = self.g1_minus_points[anchor_point.name][0], self.g1_minus_points[anchor_point.name][1]
        g2_minus_point = np.zeros(2)
        g2_minus_point[0] = x_m1 - 1 / R * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3 / 2) / (
                1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
        g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

        x_p1, y_p1 = self.g1_plus_points[anchor_point.name][0], self.g1_plus_points[anchor_point.name][1]
        g2_plus_point = np.zeros(2)
        g2_plus_point[0] = x_p1 - 1 / R * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3 / 2) / (
                1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
        g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

        self.g2_minus_points[anchor_point.name] = g2_minus_point
        self.g2_plus_points[anchor_point.name] = g2_plus_point

    return self.g2_minus_points, self.g2_plus_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_curvature_le"><code class="name flex">
<span>def <span class="ident">set_curvature_le</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curvature_le(self):
    if self.R_le.value == np.inf:
        g2_minus_point = self.g1_minus_points[&#39;le&#39;]
        g2_plus_point = self.g1_plus_points[&#39;le&#39;]
    else:
        n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(&#39;le&#39;) - 1]], self.N[&#39;le&#39;]
        theta1, theta2 = self.psi1_le.value, -self.psi2_le.value
        x0, y0 = self.anchor_points[&#39;le&#39;][0], self.anchor_points[&#39;le&#39;][1]

        x_m1, y_m1 = self.g1_minus_points[&#39;le&#39;][0], self.g1_minus_points[&#39;le&#39;][1]
        g2_minus_point = np.zeros(2)
        g2_minus_point[0] = x_m1 - 1 / self.R_le.value * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3/2) / (
                            1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
        g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

        x_p1, y_p1 = self.g1_plus_points[&#39;le&#39;][0], self.g1_plus_points[&#39;le&#39;][1]
        g2_plus_point = np.zeros(2)
        g2_plus_point[0] = x_p1 - 1 / self.R_le.value * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3/2) / (
                           1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
        g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

    return g2_minus_point, g2_plus_point</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_slope"><code class="name flex">
<span>def <span class="ident">set_slope</span></span>(<span>self, anchor_point: <a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slope(self, anchor_point: AnchorPoint):
    phi = anchor_point.phi.value
    r = anchor_point.r.value
    L = anchor_point.L.value

    if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
        self.g1_minus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] + r * L * np.array([np.cos(phi), np.sin(phi)])
        self.g1_plus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] - (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
    else:
        self.g1_minus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(phi), np.sin(phi)])
        self.g1_plus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
    return self.g1_minus_points, self.g1_plus_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, dx: float, dy: float)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Translates all the control points and anchor points by <span><span class="MathJax_Preview">\Delta x</span><script type="math/tex">\Delta x</script></span> and <span><span class="MathJax_Preview">\Delta y</span><script type="math/tex">\Delta y</script></span>.</p>
<h3 id="args">Args:</h3>
<p><code>dx</code>: <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>-direction translation magnitude</p>
<p><code>dy</code>: <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>-direction translation magnitude</p>
<h3 id="returns">Returns:</h3>
<p>The translated control point and anchor point arrays</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, dx: float, dy: float):
    &#34;&#34;&#34;
    ### Description:

    Translates all the control points and anchor points by \\(\\Delta x\\) and \\(\\Delta y\\).

    ### Args:

    `dx`: \\(x\\)-direction translation magnitude

    `dy`: \\(y\\)-direction translation magnitude

    ### Returns:

    The translated control point and anchor point arrays
    &#34;&#34;&#34;
    self.control_points[:, 0] += dx
    self.control_points[:, 1] += dy
    self.anchor_point_array[:, 0] += dx
    self.anchor_point_array[:, 1] += dy
    self.needs_update = True
    return self.control_points, self.anchor_point_array</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    self.add_anchor_points()
    self.add_free_points()
    self.extract_parameters()
    self.order_control_points()
    self.update_anchor_point_array()
    self.rotate(-self.alf.value)
    self.translate(self.dx.value, self.dy.value)
    self.generate_airfoil_coordinates()
    self.needs_update = False</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.update_anchor_point_array"><code class="name flex">
<span>def <span class="ident">update_anchor_point_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_anchor_point_array(self):
    for key in self.anchor_point_order:
        xy = self.anchor_points[key]
        if key == &#39;te_1&#39;:
            self.anchor_point_array = xy
        else:
            self.anchor_point_array = np.row_stack((self.anchor_point_array, xy))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyairpar.core" href="index.html">pyairpar.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyairpar.core.airfoil.bezier" href="#pyairpar.core.airfoil.bezier">bezier</a></code></li>
<li><code><a title="pyairpar.core.airfoil.main" href="#pyairpar.core.airfoil.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code></h4>
<ul class="">
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_anchor_point" href="#pyairpar.core.airfoil.Airfoil.add_anchor_point">add_anchor_point</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_anchor_points" href="#pyairpar.core.airfoil.Airfoil.add_anchor_points">add_anchor_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_free_point" href="#pyairpar.core.airfoil.Airfoil.add_free_point">add_free_point</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_free_points" href="#pyairpar.core.airfoil.Airfoil.add_free_points">add_free_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.check_self_intersection" href="#pyairpar.core.airfoil.Airfoil.check_self_intersection">check_self_intersection</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.compute_area" href="#pyairpar.core.airfoil.Airfoil.compute_area">compute_area</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.extract_parameters" href="#pyairpar.core.airfoil.Airfoil.extract_parameters">extract_parameters</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.generate_airfoil_coordinates" href="#pyairpar.core.airfoil.Airfoil.generate_airfoil_coordinates">generate_airfoil_coordinates</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.init_g1_points" href="#pyairpar.core.airfoil.Airfoil.init_g1_points">init_g1_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.init_g2_points" href="#pyairpar.core.airfoil.Airfoil.init_g2_points">init_g2_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.order_control_points" href="#pyairpar.core.airfoil.Airfoil.order_control_points">order_control_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.override" href="#pyairpar.core.airfoil.Airfoil.override">override</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.plot" href="#pyairpar.core.airfoil.Airfoil.plot">plot</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.rotate" href="#pyairpar.core.airfoil.Airfoil.rotate">rotate</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_curvature" href="#pyairpar.core.airfoil.Airfoil.set_curvature">set_curvature</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_curvature_le" href="#pyairpar.core.airfoil.Airfoil.set_curvature_le">set_curvature_le</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_slope" href="#pyairpar.core.airfoil.Airfoil.set_slope">set_slope</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.translate" href="#pyairpar.core.airfoil.Airfoil.translate">translate</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.update" href="#pyairpar.core.airfoil.Airfoil.update">update</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.update_anchor_point_array" href="#pyairpar.core.airfoil.Airfoil.update_anchor_point_array">update_anchor_point_array</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>