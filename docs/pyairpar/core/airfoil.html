<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyairpar.core.airfoil API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyairpar.core.airfoil</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from pyairpar.core.param import Param
from pyairpar.core.anchor_point import AnchorPoint
from pyairpar.core.free_point import FreePoint
from pyairpar.core.base_airfoil_params import BaseAirfoilParams
from pyairpar.symmetric.symmetric_base_airfoil_params import SymmetricBaseAirfoilParams
from matplotlib.axes import Axes
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import typing
from shapely.geometry import Polygon, LineString
from copy import deepcopy


class Airfoil:

    def __init__(self,
                 number_coordinates: int = 100,
                 base_airfoil_params: BaseAirfoilParams or SymmetricBaseAirfoilParams = BaseAirfoilParams(),
                 anchor_point_tuple: typing.Tuple[AnchorPoint, ...] = (),
                 free_point_tuple: typing.Tuple[FreePoint, ...] = (),
                 override_parameters: list = None
                 ):
        &#34;&#34;&#34;
        ### Description:

        `pyairpar.core.airfoil.Airfoil` is the base class for Bézier-parametrized airfoil creation.

        .. image:: complex_airfoil-3.png

        ### Args:

        `number_coordinates`: an `int` representing the number of discrete \\(x\\) - \\(y\\) coordinate pairs in each
        Bézier curve. Gets passed to the `bezier` function.

        `base_airfoil_params`: an instance of either the `pyairpar.core.base_airfoil_params.BaseAirfoilParams` class or
        the `pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams` class which defines the base
        set of parameters to be used

        `anchor_point_tuple`: a `tuple` of `pyairpar.core.anchor_point.AnchorPoint` objects. To specify a single
        anchor point, use `(pyairpar.core.anchor_point.AnchorPoint(),)`. Default: `()`

        `free_point_tuple`: a `tuple` of `pyairpar.core.free_point.FreePoint` objects. To specify a single free
        point, use `(pyairpar.core.free_point.FreePoint(),)`. Default: `()`

        ### Returns:

        An instance of the `Airfoil` class
        &#34;&#34;&#34;

        self.nt = number_coordinates
        self.params = []
        self.base_airfoil_params = base_airfoil_params
        self.override_parameters = override_parameters

        self.override_parameter_start_idx = 0
        self.override_parameter_end_idx = self.base_airfoil_params.n_overrideable_parameters
        if self.override_parameters is not None:
            self.base_airfoil_params.override(
                self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
        self.override_parameter_start_idx += self.base_airfoil_params.n_overrideable_parameters

        self.c = base_airfoil_params.c
        self.alf = base_airfoil_params.alf
        self.R_le = base_airfoil_params.R_le
        self.L_le = base_airfoil_params.L_le
        self.r_le = base_airfoil_params.r_le
        self.phi_le = base_airfoil_params.phi_le
        self.psi1_le = base_airfoil_params.psi1_le
        self.psi2_le = base_airfoil_params.psi2_le
        self.L1_te = base_airfoil_params.L1_te
        self.L2_te = base_airfoil_params.L2_te
        self.theta1_te = base_airfoil_params.theta1_te
        self.theta2_te = base_airfoil_params.theta2_te
        self.t_te = base_airfoil_params.t_te
        self.r_te = base_airfoil_params.r_te
        self.phi_te = base_airfoil_params.phi_te
        self.dx = base_airfoil_params.dx
        self.dy = base_airfoil_params.dy

        # Ensure that all the trailing edge parameters are no longer active if the trailing edge thickness is set to 0.0
        if self.t_te.value == 0.0:
            self.r_te.active = False
            self.phi_te.active = False

        self.C = []
        self.free_points = {}
        self.param_dicts = {}
        self.coords = None
        self.non_transformed_coords = None
        self.curvature = None
        self.area = None
        self.x_thickness = None
        self.thickness = None
        self.max_thickness = None

        self.needs_update = True

        self.anchor_point_tuple = anchor_point_tuple

        if self.override_parameters is not None:
            for anchor_point in self.anchor_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    anchor_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  anchor_point.n_overrideable_parameters
                anchor_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += anchor_point.n_overrideable_parameters

        self.free_point_tuple = free_point_tuple

        if self.override_parameters is not None:
            for free_point in self.free_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    free_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  free_point.n_overrideable_parameters
                free_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += free_point.n_overrideable_parameters

        self.anchor_points = {&#39;te_1&#39;: self.c.value * np.array([1, 0]) + self.r_te.value * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)]),
                              &#39;le&#39;: np.array([0.0, 0.0]),
                              &#39;te_2&#39;: self.c.value * np.array([1, 0]) -
                                      (1 - self.r_te.value) * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)])}
        self.transformed_anchor_points = None
        self.anchor_point_order = [&#39;te_1&#39;, &#39;le&#39;, &#39;te_2&#39;]
        self.anchor_point_array = np.array([])

        self.N = {
            &#39;te_1&#39;: 4,
            &#39;le&#39;: 4
        }

        self.control_points = np.array([])
        self.n_control_points = len(self.control_points)

        self.g1_minus_points, self.g1_plus_points = self.init_g1_points()
        self.g2_minus_points, self.g2_plus_points = self.init_g2_points()

        self.update()

    def init_g1_points(self):
        &#34;&#34;&#34;
        ### Description:

        Initializes the &#34;g1_minus&#34; and &#34;g1_plus&#34; points for the leading edge (the neighboring control points to
        the leading edge anchor point). These points are used to enforce \\(G^1\\) continuity. &#34;Minus&#34; points refer to
        control points which occur before the anchor point in the path of the Bézier curve, and &#34;plus&#34; points refer to
        control points which occur before the anchor point.

        ### Returns:

        The neighboring control points to the leading edge anchor point as dictionaries.
        &#34;&#34;&#34;

        g1_minus_points = {
            &#39;te_2&#39;: self.anchor_points[&#39;te_2&#39;] +
                  self.L2_te.value * np.array([-np.cos(self.theta2_te.value),
                                               -np.sin(self.theta2_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] +
                  self.r_le.value * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        g1_plus_points = {
            &#39;te_1&#39;: self.anchor_points[&#39;te_1&#39;] +
                    self.L1_te.value * np.array([-np.cos(self.theta1_te.value),
                                                 np.sin(self.theta1_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] -
                  (1 - self.r_le.value) * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        return g1_minus_points, g1_plus_points

    def init_g2_points(self):
        &#34;&#34;&#34;
        ### Description:

        Initializes the &#34;g2_minus&#34; and &#34;g2_plus&#34; points for the leading edge (the control points two points from the
        leading edge control point). These points are used to enforce \\(G^2\\) continuity. &#34;Minus&#34; points refer to
        control points which occur before the anchor point in the path of the Bézier curve, and &#34;plus&#34; points refer to
        control points which occur before the anchor point.

        ### Returns:

        The neighboring control points to the leading edge anchor point as dictionaries.
        &#34;&#34;&#34;
        g2_minus_point_le, g2_plus_point_le = self.set_curvature_le()

        g2_minus_points = {
            &#39;le&#39;: g2_minus_point_le
        }

        g2_plus_points = {
            &#39;le&#39;: g2_plus_point_le
        }

        return g2_minus_points, g2_plus_points

    def set_slope(self, anchor_point: AnchorPoint):
        r&#34;&#34;&#34;
        ### Description:

        This is the function which enforces \(G^1\) continuity for all `pyairpar.core.anchor_point.AnchorPoint`s
        which are added. To keep the length ratios and angles defined in a &#34;nice&#34; way, the neighboring control points
        to the anchor point are defined as follows: For anchor points on the upper surface (where \((x_0,
        y_0)\) precedes the leading edge point):

        $$\begin{align*}
        \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
        (1-r)L \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix} \\
        \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
        rL \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix}
        \end{align*}$$

        For anchor points on the lower surface (where \((x_0,y_0)\) occurs further down the Bézier curve path than
        the leading edge point):

        $$\begin{align*}
        \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
        rL \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix} \\
        \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
        (1-r)L \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix}
        \end{align*}$$

        Here, \((x_{-1},y_{-1})\) represents the coordinates of the &#34;minus&#34; point (the control point before the
        leading edge point), and \((x_{+1},y_{+1})\) represents the coordinates of the &#34;plus&#34; point (the control
        point after the leading edge point). The coordinates of the anchor point itself are \((x_0,y_0)\). With
        these definitions, a ratio \(r&gt;0.5\) biases the neighboring control points toward the leading edge, and
        a ratio \(r&lt;0.5\) biases the neighboring control points toward the leading edge. A positive value of \(\phi\)
        angles the neighboring control points toward the trailing edge, and a negative value of \(\phi\) angles the
        neighboring control points toward the trailing edge. See the diagram for
        `pyairpar.core.anchor_point.AnchorPoint` for a visual description of these definitions.

        ### Returns:

        The generated neighboring control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
        &#34;&#34;&#34;
        r = anchor_point.r.value
        L = anchor_point.L.value
        phi = anchor_point.phi.value

        if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(phi), np.sin(phi)])
        else:
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(-phi), np.sin(-phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(-phi), np.sin(-phi)])
        return self.g1_minus_points[anchor_point.name], self.g1_plus_points[anchor_point.name]

    def set_curvature_le(self):
        r&#34;&#34;&#34;
        ### Description:

        See the description of `pyairpar.core.airfoil.Airfoil.set_curvature()`. This is just a special case of that
        function tailored for the leading edge of the airfoil. Here, \(\psi_1\) defines the angle of the upper
        curvature control arm, and \(\psi_2\) defines the angle of the lower curvature control arm. See also
        `pyairpar.core.base_airfoil_params.BaseAirfoilParams` for more details on the definitions of the attribute
        parameters input to this function.

        ### Returns:

        The generated curvature control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
        &#34;&#34;&#34;
        if self.R_le.value == np.inf or self.R_le.value == -np.inf:
            g2_minus_point = self.g1_minus_points[&#39;le&#39;]
            g2_plus_point = self.g1_plus_points[&#39;le&#39;]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(&#39;le&#39;) - 1]], self.N[&#39;le&#39;]
            theta1, theta2 = self.psi1_le.value, -self.psi2_le.value
            x0, y0 = self.anchor_points[&#39;le&#39;][0], self.anchor_points[&#39;le&#39;][1]

            x_m1, y_m1 = self.g1_minus_points[&#39;le&#39;][0], self.g1_minus_points[&#39;le&#39;][1]
            g2_minus_point = np.zeros(2)
            g2_minus_point[0] = x_m1 - 1 / self.R_le.value * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3/2) / (
                                1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

            x_p1, y_p1 = self.g1_plus_points[&#39;le&#39;][0], self.g1_plus_points[&#39;le&#39;][1]
            g2_plus_point = np.zeros(2)
            g2_plus_point[0] = x_p1 - 1 / self.R_le.value * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3/2) / (
                               1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

        return g2_minus_point, g2_plus_point

    def set_curvature(self, anchor_point: AnchorPoint):
        r&#34;&#34;&#34;
        ### Description:

        This is the function which enforces \(G^2\) continuity for all `pyairpar.core.anchor_point.AnchorPoint`s
        which are added. To keep the length ratios and angles defined in a &#34;nice&#34; way, the neighboring control points
        to the anchor point&#39;s slope-control points are defined as follows:

        $$
        \begin{align*}
            \begin{bmatrix} x_{-2} \\ y_{-2} \end{bmatrix} &amp;=
            \begin{cases}
                \begin{bmatrix} x_{-1} + \frac{c_1}{c_2[c_3(\tan{(\theta_1)} + y_0 - y_{-1})]}
                                \\ \tan{(\theta_1)} (x_{-2} - x_{-1}) + y_{-1} \end{bmatrix}
                                ,&amp; \theta_1 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
                \begin{bmatrix} x_{-1} \\ y_{-1} + \frac{c_1}{c_2 c_3}  \end{bmatrix},&amp; \theta_1 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
                                                                                                    R \in (-\infty,0)
                                                                                                    \cup (0,\infty) \\
                \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix},&amp; \theta_1 \in (-\infty, \infty) \wedge R =
                                                                                                            \pm \infty
            \end{cases} \\
            \begin{bmatrix} x_{+2} \\ y_{+2} \end{bmatrix} &amp;=
            \begin{cases}
                \begin{bmatrix} x_{+1} + \frac{c_4}{c_5[c_6(\tan{(\theta_2)} + y_{+1} - y_0)]}
                                \\ \tan{(\theta_2)} (x_{+2} - x_{+1}) + y_{+1} \end{bmatrix}
                                ,&amp; \theta_2 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
                \begin{bmatrix} x_{+1} \\ y_{+1} + \frac{c_4}{c_5 c_6}  \end{bmatrix},&amp; \theta_2 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
                                                                                                    R \in (-\infty,0)
                                                                                                    \cup (0,\infty) \\
                \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix},&amp; \theta_2 \in (-\infty, \infty) \wedge R =
                                                                                                            \pm \infty
            \end{cases}
        \end{align*}
        $$
        where
        $$
        \begin{align*}
        c_1 &amp;= \frac{-1}{R}[(x_0-x_{-1})^2 + (y_0-y_{-1})^2]^{3/2} \\
        c_2 &amp;= 1 - \frac{1}{n_1} \\
        c_3 &amp;= x_{-1} - x_0 \\
        c_4 &amp;= \frac{-1}{R}[(x_{+1}-x_0)^2 + (y_{+1}-y_0)^2]^{3/2} \\
        c_5 &amp;= 1 - \frac{1}{n_2} \\
        c_6 &amp;= x_0 - x_{+1}
        \end{align*}
        $$

        Here, \(n_1\) is the order of the Bézier curve preceding the anchor point, and \(n_2\) is the order of the
        Bézier curve following the anchor point. \((x_0,y_0)\) is the anchor point location, \((x_{-1},y_{-1})\)
        and \((x_{+1},y_{+1})\) are the neighboring control points, and \((x_{-2},y_{-2})\) and \((x_{+2},y_{+2})\)
        are the curvature control points. \(\theta_1\) and \(\theta_2\) are governed by the following relationships:

        $$
        \begin{align*}
            \theta_1 &amp;=
            \begin{cases}
                \psi_1 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
                \pi + \psi_2 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
                \pi - \psi_1 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
                -\psi_2 - \phi,&amp; R &lt; 0,\,\text{lower surface}
            \end{cases} \\
            \theta_2 &amp;=
            \begin{cases}
                -\psi_2 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
                \psi_1 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
                \pi + \psi_2 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
                \psi_1 - \phi,&amp; R &lt; 0,\,\text{lower surface}
            \end{cases}
        \end{align*}
        $$
        By these definitions of the curvature control arm angles, decreasing \(\psi_1\) or \(\psi_2\) from
        \(90^{\circ}\) has the effect of &#34;tucking&#34; the arms in, and increasing \(\psi_1\) or \(\psi_2\) from
        \(90^{\circ}\) has the effect of &#34;spreading&#34; the arms out. See the documentation for
        `pyairpar.core.anchor_point.AnchorPoint` for further description and a visual.

        .. note:: A value of \( R = \frac{1}{\kappa} = 0 \) (infinite curvature) is not well-defined for geometric shapes. Setting \(R = 0\) will yield an exception.

        ### Returns:

        The generated curvature control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
        &#34;&#34;&#34;
        R = anchor_point.R.value
        if R == np.inf or R == -np.inf:
            self.g2_minus_points[anchor_point.name] = self.g1_minus_points[anchor_point.name]
            self.g2_plus_points[anchor_point.name] = self.g1_plus_points[anchor_point.name]
            g2_minus_point = self.g2_minus_points[anchor_point.name]
            g2_plus_point = self.g2_plus_points[anchor_point.name]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(anchor_point.name) - 1]], \
                     self.N[anchor_point.name]
            if R &gt; 0:  # If the radius of curvature is positive,
                if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
                    theta1, theta2 = anchor_point.psi1.value + anchor_point.phi.value, \
                                     -anchor_point.psi2.value + anchor_point.phi.value
                else:
                    theta2, theta1 = - anchor_point.psi1.value - anchor_point.phi.value, \
                                     np.pi + anchor_point.psi2.value - anchor_point.phi.value
            else:  # If the radius of curvature is negative,
                if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
                    theta1, theta2 = np.pi - anchor_point.psi1.value + anchor_point.phi.value, \
                                     np.pi + anchor_point.psi2.value + anchor_point.phi.value
                else:
                    theta2, theta1 = anchor_point.psi1.value - anchor_point.phi.value, \
                                     -anchor_point.psi2.value - anchor_point.phi.value
            x0, y0 = anchor_point.xy[0], anchor_point.xy[1]

            x_m1, y_m1 = self.g1_minus_points[anchor_point.name][0], self.g1_minus_points[anchor_point.name][1]
            g2_minus_point = np.zeros(2)
            c1 = - 1 / R * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3 / 2)
            c2 = 1 - 1 / n1
            c3 = x_m1 - x0
            if (theta1 - np.pi / 2) % np.pi != 0:
                g2_minus_point[0] = x_m1 + c1 / c2 / (c3 * np.tan(theta1) + y0 - y_m1)
                g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1
            else:
                g2_minus_point[0] = x_m1
                g2_minus_point[1] = y_m1 + c1 / c2 / c3

            x_p1, y_p1 = self.g1_plus_points[anchor_point.name][0], self.g1_plus_points[anchor_point.name][1]
            g2_plus_point = np.zeros(2)
            c4 = - 1 / R * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3 / 2)
            c5 = 1 - 1 / n2
            c6 = x0 - x_p1
            if (theta2 - np.pi / 2) % np.pi != 0:
                g2_plus_point[0] = x_p1 + c4 / c5 / (c6 * np.tan(theta2) + y_p1 - y0)
                g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1
            else:
                g2_plus_point[0] = x_p1
                g2_plus_point[1] = y_p1 + c4 / c5 / c6

            self.g2_minus_points[anchor_point.name] = g2_minus_point
            self.g2_plus_points[anchor_point.name] = g2_plus_point

        return g2_minus_point, g2_plus_point

    def extract_parameters(self):
        &#34;&#34;&#34;
        ### Description:

        This function extracts every parameter from the `pyairpar.core.base_airfoil_params.BaseAirfoilParams`, all the
        `pyairpar.core.anchor_point.AnchorPoint`s, and all the `pyairpar.core.free_point.FreePoint`s with
        `active=True` and `linked=False` as a `list` of parameter values.
        &#34;&#34;&#34;

        self.params = [var for var in vars(self.base_airfoil_params).values()
                       if isinstance(var, Param) and var.active and not var.linked]

        for anchor_point in self.anchor_point_tuple:

            self.params.extend([var for var in vars(anchor_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

        for free_point in self.free_point_tuple:

            self.params.extend([var for var in vars(free_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

    def order_control_points(self):
        &#34;&#34;&#34;
        ### Description:

        This function creates an array of control points based on the anchor, neighboring, and curvature control
        point dictionaries based on the `string`-based `anchor_point_order`.

        ### Returns:

        The control point array and the length of the control point array (number of control points)
        &#34;&#34;&#34;
        self.control_points = np.array([])
        for idx, anchor_point in enumerate(self.anchor_point_order):

            if idx == 0:
                self.control_points = np.append(self.control_points, self.anchor_points[anchor_point])
                self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
            else:
                if anchor_point in self.g2_minus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.g1_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.anchor_points[anchor_point]))
                if anchor_point in self.g1_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
                if anchor_point in self.g2_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_plus_points[anchor_point]))

            if anchor_point in self.free_points:
                if len(self.free_points[anchor_point]) &gt; 0:
                    for fp_idx in range(len(self.free_points[anchor_point])):
                        self.control_points = \
                            np.row_stack((self.control_points, self.free_points[anchor_point][fp_idx, :]))

        self.n_control_points = len(self.control_points)
        return self.control_points, self.n_control_points

    def add_free_point(self, free_point: FreePoint):
        &#34;&#34;&#34;
        ### Description:

        Adds a free point (and 2 degrees of freedom) to a given Bézier curve (defined by the `previous_anchor_point`)

        ### Args:

        `free_point`: a `pyairpar.core.free_point.FreePoint` to add to a Bézier curve
        &#34;&#34;&#34;
        if free_point.previous_anchor_point not in self.free_points.keys():
            self.free_points[free_point.previous_anchor_point] = np.array([])
        if len(self.free_points[free_point.previous_anchor_point]) == 0:
            self.free_points[free_point.previous_anchor_point] = free_point.xy.reshape((1, 2))
        else:
            self.free_points[free_point.previous_anchor_point] = np.vstack(
                (self.free_points[free_point.previous_anchor_point], free_point.xy))

        self.needs_update = True

    def set_bezier_curve_orders(self):
        for anchor_point in self.anchor_point_tuple:
            self.N[anchor_point.name] = 5
            if anchor_point.name not in self.anchor_point_order:
                self.anchor_point_order.insert(self.anchor_point_order.index(anchor_point.previous_anchor_point) + 1,
                                               anchor_point.name)
        if self.anchor_point_order.index(&#39;te_2&#39;) - self.anchor_point_order.index(&#39;le&#39;) != 1:
            self.N[&#39;le&#39;] = 5  # Set the order of the Bézier curve after the leading edge to 5
            self.N[self.anchor_point_order[-2]] = 4  # Set the order of the last Bezier curve to 4
        for free_point in self.free_point_tuple:
            # Increment the order of the modified Bézier curve
            self.N[free_point.previous_anchor_point] += 1

    def add_anchor_point(self, anchor_point: AnchorPoint):
        &#34;&#34;&#34;
        ### Description:

        Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
        control point branch into the set of control points. `needs_update` is set to `True`.

        ### Args:

        `anchor_point`: an `pyairpar.core.anchor_point.AnchorPoint` from which to build a control point branch
        &#34;&#34;&#34;
        self.anchor_points[anchor_point.name] = anchor_point.xy
        self.set_slope(anchor_point)
        self.set_curvature(anchor_point)
        self.needs_update = True

    def add_anchor_points(self):
        &#34;&#34;&#34;
        ### Description:

        This function executes `pyairpar.core.airfoil.Airfoil.add_anchor_point()` for all the anchor points in the
        `anchor_point_tuple`. Enforces leading edge and trailing edge Bézier curve orders.
        `needs_update` is set to `True`.
        &#34;&#34;&#34;
        for anchor_point in self.anchor_point_tuple:
            self.add_anchor_point(anchor_point)
        self.needs_update = True

    def add_free_points(self):
        &#34;&#34;&#34;
        ### Description:

        This function executes `pyairpar.core.airfoil.Airfoil.add_free_point()` for all the anchor points in the
        `free_point_tuple`. `needs_update` is set to `True`.
        &#34;&#34;&#34;
        for free_point in self.free_point_tuple:
            self.add_free_point(free_point)
        self.needs_update = True

    def update_anchor_point_array(self):
        r&#34;&#34;&#34;
        ### Description:

        This function updates the `anchor_point_array` attribute of `pyairpar.core.airfoil.Airfoil`, which is a
        `np.ndarray` of `shape=(N, 2)`, where `N` is the number of anchor points in the airfoil, and the columns
        represent the \(x\) and \(y\) coordinates.
        &#34;&#34;&#34;
        for key in self.anchor_point_order:
            xy = self.anchor_points[key]
            if key == &#39;te_1&#39;:
                self.anchor_point_array = xy
            else:
                self.anchor_point_array = np.row_stack((self.anchor_point_array, xy))
        self.transformed_anchor_points = deepcopy(self.anchor_points)

    def update(self):
        r&#34;&#34;&#34;
        ### Description:

        The `update` function adds first all of the anchor points in the `anchor_point_tuple` and then all of the free
        points in the `free_point_tuple`. The parameter information is extracted. The control points are ordered
        based on the `anchor_point_order`, `name` attributes, and `previous_anchor_point` attributes. The
        `anchor_point_array` is updated based on the anchor points added. Airfoil coordinates are generated and saved.
        Rotation to the specified angle of attack
        and translation by the specified \(\Delta x\), \(\Delta y\) are applied, in that order. The Bézier
        curves are generated through the control points and the airfoil coordinates are then calculated again after
        the transformations.
        &#34;&#34;&#34;
        self.set_bezier_curve_orders()
        self.add_anchor_points()
        self.add_free_points()
        self.extract_parameters()
        self.order_control_points()
        self.update_anchor_point_array()
        self.generate_non_transformed_airfoil_coordinates()
        self.rotate(-self.alf.value)
        self.translate(self.dx.value, self.dy.value)
        self.generate_airfoil_coordinates()
        self.needs_update = False

    def override(self, parameters):
        &#34;&#34;&#34;
        ### Description:

        This function re-initializes the `Airfoil` object using the list of `override_parameters`

        ### Args:

        `parameters`: a list of `override_parameters` generated by `extract_parameters` and possibly modified.
        &#34;&#34;&#34;
        self.__init__(self.nt, self.base_airfoil_params, self.anchor_point_tuple, self.free_point_tuple,
                      override_parameters=parameters)

    def translate(self, dx: float, dy: float):
        &#34;&#34;&#34;
        ### Description:

        Translates all the control points and anchor points by \\(\\Delta x\\) and \\(\\Delta y\\).

        ### Args:

        `dx`: \\(x\\)-direction translation magnitude

        `dy`: \\(y\\)-direction translation magnitude

        ### Returns:

        The translated control point and anchor point arrays
        &#34;&#34;&#34;
        self.control_points[:, 0] += dx
        self.control_points[:, 1] += dy
        self.anchor_point_array[:, 0] += dx
        self.anchor_point_array[:, 1] += dy
        for key, anchor_point in self.transformed_anchor_points.items():
            self.transformed_anchor_points[key] = anchor_point + np.array([dx, dy])
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def rotate(self, angle: float):
        &#34;&#34;&#34;
        ### Description:

        Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.

        ### Args:

        `angle`: Angle (in radians) by which to rotate the airfoil.

        ### Returns:

        The rotated control point and anchor point arrays
        &#34;&#34;&#34;
        rot_mat = np.array([[np.cos(angle), -np.sin(angle)],
                            [np.sin(angle), np.cos(angle)]])
        self.control_points = (rot_mat @ self.control_points.T).T
        self.anchor_point_array = (rot_mat @ self.anchor_point_array.T).T
        for key, anchor_point in self.transformed_anchor_points.items():
            self.transformed_anchor_points[key] = (rot_mat @ anchor_point.T).T
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def generate_coords(self):
        &#34;&#34;&#34;
        ### Description:

        Generates the Bézier curves through the control points. Also re-casts the Bézier curve points in terms of
        airfoil coordinates by removing the points shared by joined Bézier curves. Curvature information is extracted
        from the `C` dictionary. Helper method for `generate_airfoil_coordinates()` and
        `generate_non_transformed_airfoil_coordinates()`.

        ### Returns:

        The airfoil coordinates and the curvature of the airfoil.
        &#34;&#34;&#34;
        if self.C:
            self.C = []
        P_start_idx = 0
        for idx in range(len(self.anchor_point_order) - 1):
            P_length = self.N[self.anchor_point_order[idx]] + 1
            P_end_idx = P_start_idx + P_length
            P = self.control_points[P_start_idx:P_end_idx, :]
            C = bezier(P, self.nt)
            self.C.append(C)
            P_start_idx = P_end_idx - 1
        coords = np.array([])
        curvature = np.array([])
        for idx in range(len(self.C)):
            if idx == 0:
                coords = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;y&#39;]))
                curvature = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;k&#39;]))
            else:
                coords = np.row_stack((coords, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;y&#39;][1:]))))
                curvature = np.row_stack((curvature, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;k&#39;][1:]))))
        return coords, curvature

    def generate_airfoil_coordinates(self):
        &#34;&#34;&#34;
        ### Description:

        Runs the `generate_coords()` method after the rotation and translation steps and saves the information to
        the `coords` and `curvature` attributes of `Airfoil`. Used in `Airfoil.update()`.

        ### Returns:

        The airfoil coordinates, the `C` dictionary of Bézier curve information, and the curvature.
        &#34;&#34;&#34;
        coords, curvature = self.generate_coords()
        self.coords = coords
        self.curvature = curvature
        return self.coords, self.C, self.curvature

    def generate_non_transformed_airfoil_coordinates(self):
        &#34;&#34;&#34;
        ### Description:

        Runs the `generate_coords()` method before the rotation and translation steps and saves the information to the
        `non_transformed_coords` attribute of `Airfoil`. Used in `Airfoil.update()`.

        ### Returns:

        The coordinates of the airfoil before rotation and translation.
        &#34;&#34;&#34;
        coords, _ = self.generate_coords()
        self.non_transformed_coords = coords
        return self.non_transformed_coords

    def compute_area(self):
        &#34;&#34;&#34;
        ### Description:

        Computes the area of the airfoil as the area of a many-sided polygon enclosed by the airfoil coordinates using
        the [shapely](https://shapely.readthedocs.io/en/stable/manual.html) library.

        ### Returns:
        The area of the airfoil
        &#34;&#34;&#34;
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        polygon = Polygon(points_shapely)
        area = polygon.area
        self.area = area
        return area

    def check_self_intersection(self):
        &#34;&#34;&#34;
        ### Description:

        Determines whether the airfoil intersects itself using the `is_simple()` function of the
        [`shapely`](https://shapely.readthedocs.io/en/stable/manual.html) library.

        ### Returns:

        A `bool` value describing whether the airfoil intersects itself
        &#34;&#34;&#34;
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        line_string = LineString(points_shapely)
        is_simple = line_string.is_simple
        return not is_simple

    def compute_thickness(self, n_lines: int = 201):
        r&#34;&#34;&#34;
        ### Description:

        Calculates the thickness distribution and maximum thickness of the airfoil.

        ### Args:

        `n_lines`: Optional `int` describing the number of lines evenly spaced along the chordline produced to
        determine the thickness distribution. Default: `201`.

        ### Returns:

        The list of \(x\)-values used for the thickness distribution calculation, the thickness distribution, and the
        maximum value of the thickness distribution.
        &#34;&#34;&#34;
        points_shapely = list(map(tuple, self.non_transformed_coords))
        airfoil_line_string = LineString(points_shapely)
        x_thickness = np.linspace(0.0, self.c.value, n_lines)
        thickness = []
        for idx in range(n_lines):
            line_string = LineString([(x_thickness[idx], -1), (x_thickness[idx], 1)])
            x_inters = line_string.intersection(airfoil_line_string)
            if x_inters.is_empty:
                thickness.append(0.0)
            else:
                thickness.append(x_inters.convex_hull.length)
        self.x_thickness = x_thickness
        self.thickness = thickness
        self.max_thickness = max(thickness)
        return self.x_thickness, self.thickness, self.max_thickness

    def plot(self, plot_what: typing.Tuple[str, ...], fig: Figure = None, axs: Axes = None, show_plot: bool = True,
             save_plot: bool = False, save_path: str = None, plot_kwargs: typing.List[dict] = None,
             show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5,
             tight_layout: bool = True, axis_equal: bool = True):
        r&#34;&#34;&#34;
        ### Description:

        A variety of airfoil plotting options using [`matplotlib`](https://matplotlib.org/). Many wrapper options
        are available here, but custom plots can also be created directly from the `coords`, `curvature`, `C`,
        `control_points`, and `anchor_point_array` attributes of the `Airfoil` class.

        ### Args:

        `plot_what`: One or more of `&#34;airfoil&#34;`, `&#34;anchor-point-skeleton&#34;`, `&#34;control-point-skeleton&#34;`,
        `&#34;chordline&#34;`, `&#34;R-circles&#34;`, or `&#34;curvature&#34;`.

        `fig`: The
        [`matplotlib.figure.Figure`](https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure)
        object as a canvas input. New `Figure` is created if `None`. Default: `None`.

        `axs`: The
        [`matplotlib.axes.Axes`](https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class)
        object as a axes input. New `Axes` is created if `None`. Default: `None`.

        `show_plot`: Whether to show the plot (`bool`). Default: `True`.

        `save_plot`: Whether to save the plot (`bool`). Default: `False`.

        `save_path`: A `str` describing the root directory, filename, and image extension of the path to save. Only
        used if `save_plot` is `True`. Default: `None`.

        `plot_kwargs`: A list of dictionaries with [`matplotlib`](https://matplotlib.org/) keyword arguments to be
        unpacked and applied to each Bézier curve element-by-element. Default: `None`.

        `show_title`: Whether to show a title describing the airfoil chord length, angle of attack, and area (`bool`).
        Default: `True`.

        `show_legend`: Whether to show the legend (`bool`). Default: `True`.

        `figwidth`: The width of the figure, in inches (`float`). Default: `10.0`.

        `figheight`: The height of the figure, in inches (`float`). Default: `2.5`.

        `tight_layout`: Whether to tighten the margins around the plot (`bool`). Default: `True`.

        `axis_equal`: Whether to set the aspect ratio of the plot to equal \(x\) and \(y\) (`bool`). Default: `True`.

        ### Returns:

        A tuple of the
        [`matplotlib.figure.Figure`](https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure)
        object and the
        [`matplotlib.axes.Axes`](https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class)
        object used for plotting
        &#34;&#34;&#34;
        if self.needs_update:
            self.update()
        if fig is None and axs is None:
            fig, axs = plt.subplots(1, 1)

        for what_to_plot in plot_what:

            if what_to_plot == &#39;airfoil&#39;:
                for idx, C in enumerate(self.C):
                    if plot_kwargs is None:
                        if idx == 0:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;, label=&#39;airfoil&#39;)
                        else:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;)
                    else:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], **plot_kwargs[idx])

            if what_to_plot == &#39;anchor-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], &#39;:x&#39;, color=&#39;black&#39;,
                             label=&#39;anchor point skeleton&#39;)
                else:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], **plot_kwargs)

            if what_to_plot == &#39;control-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], &#39;--*&#39;, color=&#39;grey&#39;,
                             label=&#39;control point skeleton&#39;)
                else:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], **plot_kwargs)
            if what_to_plot == &#39;chordline&#39;:
                if plot_kwargs is None:
                    axs.plot(np.array([0 + self.dx.value, self.c.value * np.cos(self.alf.value) + self.dx.value]),
                             np.array([0 + self.dy.value, -self.c.value * np.sin(self.alf.value) + self.dy.value]),
                             &#39;-.&#39;, color=&#39;indianred&#39;, label=&#39;chordline&#39;)
                else:
                    axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                             np.array([0, -self.c.value * np.sin(self.alf.value)]), **plot_kwargs)
            if what_to_plot == &#39;R-circles&#39;:
                line = [[0 + self.dx.value, self.R_le.value *
                         np.cos(self.phi_le.value - self.alf.value) + self.dx.value],
                        [0 + self.dy.value, self.R_le.value *
                         np.sin(self.phi_le.value - self.alf.value) + self.dy.value]]
                circle = plt.Circle((line[0][1], line[1][1]), self.R_le.value, fill=False, color=&#39;gold&#39;,
                                    label=&#39;R circle&#39;)
                axs.plot(line[0], line[1], color=&#39;gold&#39;)
                axs.add_patch(circle)
                for anchor_point in self.anchor_point_tuple:
                    xy = self.anchor_point_array[self.anchor_point_order.index(anchor_point.name), :]
                    if self.anchor_point_order.index(anchor_point.name) &gt; self.anchor_point_order.index(&#39;le&#39;):
                        perp_angle = np.pi / 2
                        phi = -anchor_point.phi.value
                    else:
                        perp_angle = -np.pi / 2
                        phi = anchor_point.phi.value
                    line = np.array([xy, xy + anchor_point.R.value *
                                     np.array([np.cos(phi - self.alf.value + perp_angle),
                                               np.sin(phi - self.alf.value + perp_angle)])])
                    circle = plt.Circle((line[1, 0], line[1, 1]), anchor_point.R.value, fill=False, color=&#39;gold&#39;)
                    axs.plot(line[:, 0], line[:, 1], color=&#39;gold&#39;)
                    axs.add_patch(circle)
            if what_to_plot == &#39;curvature&#39;:
                if plot_kwargs is None:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], color=&#39;cornflowerblue&#39;, label=&#39;curvature&#39;)
                else:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], **plot_kwargs)

        if axis_equal:
            axs.set_aspect(&#39;equal&#39;, &#39;box&#39;)
        if show_title:
            area = self.compute_area()
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$, $A={area:.5f}$&#39;)
        else:
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$&#39;)
        if tight_layout:
            fig.tight_layout()
        fig.set_figwidth(figwidth)
        fig.set_figheight(figheight)
        if show_legend:
            axs.legend()
        if save_plot:
            fig.savefig(save_path)
        if show_plot:
            plt.show()
        return fig, axs


def bezier(P: np.ndarray, nt: int) -&gt; dict:
    &#34;&#34;&#34;
    ### Description:

    Computes the Bézier curve through the control points `P` according to
    $$\\vec{C}(t)=\\sum_{i=0}^n \\vec{P}_i B_{i,n}(t)$$ where \\(B_{i,n}(t)\\) is the Bernstein polynomial, given by
    $$B_{i,n}={n \\choose i} t^i (1-t)^{n-i}$$

    Also included are first derivative, second derivative, and curvature information. These are given by
    $$\\vec{C}&#39;(t)=n \\sum_{i=0}^{n-1} (\\vec{P}_{i+1} - \\vec{P}_i B_{i,n-1}(t)$$
    $$\\vec{C}&#39;&#39;(t)=n(n-1) \\sum_{i=0}^{n-2} (\\vec{P}_{i+2}-2\\vec{P}_{i+1}+\\vec{P}_i) B_{i,n-2}(t)$$
    $$\\kappa(t)=\\frac{C&#39;_x(t) C&#39;&#39;_y(t) - C&#39;_y(t) C&#39;&#39;_x(t)}{[(C&#39;_x)^2(t) + (C&#39;_y)^2(t)]^{3/2}}$$

    Here, the \\(&#39;\\) and \\(&#39;&#39;\\) are the first and second derivatives with respect to \\(x\\) and \\(y\\), not the
    parameter \\(t\\). The result of \\(\\vec{C}&#39;&#39;(t)\\), for example, is a vector with two components, \\(C&#39;&#39;_x(t)\\)
    and \\(C&#39;&#39;_y(t)\\).

    An example cubic Bézier curve (order \\(n=3\\)) is shown below. Note that the curve passes through the first and
    last control points and has a local slope at \\(P_0\\) equal to the slope of the line passing through \\(P_0\\)
    and \\(P_1\\). Similarly, the local slope at \\(P_3\\) is equal to the slope of the line passing through
    \\(P_2\\) and \\(P_3\\). These properties of Bézier curves allow us to easily enforce \\(G^0\\) and \\(G^1\\)
    continuity at Bézier curve &#34;joints&#34; (common endpoints of connected Bézier curves).

    .. image:: bezier_curve.png

    ### Args:

    `P`: The control point `np.ndarray` of `shape=(n+1, 2)`, where `n` is the order of the Bézier curve and `n+1` is
    the number of control points in the Bézier curve. The two columns represent the \\(x\\)- and \\(y\\) -components of
    the control points.

    `nt`: number of points in the `t` vector (defines the resolution of the curve)

    ### Returns:

    A dictionary of `numpy` arrays of `shape=nt` containing information related to the created Bézier curve:

    $$C_x(t), C_y(t), C&#39;_x(t), C&#39;_y(t), C&#39;&#39;_x(t), C&#39;&#39;_y(t), \\kappa(t)$$
    where the \\(x\\) and \\(y\\) subscripts represent the \\(x\\) and \\(y\\) components of the vector-valued functions
    \\(\\vec{C}(t)\\), \\(\\vec{C}&#39;(t)\\), and \\(\\vec{C}&#39;&#39;(t)\\).
    &#34;&#34;&#34;

    def nCr(n_, r):
        &#34;&#34;&#34;
        ### Description:

        Simple function that computes the mathematical combination $$n \\choose r$$

        ### Args:

        `n_`: `n` written with a trailing underscore to avoid conflation with the order `n` of the Bézier curve

        `r&#39;

        ### Returns

        $$n \\choose r$$
        &#34;&#34;&#34;
        f = np.math.factorial
        return f(n_) / f(r) / f(n_ - r)

    t = np.linspace(0, 1, nt)
    C = {
        &#39;t&#39;: t,
        &#39;x&#39;: 0,
        &#39;y&#39;: 0,
        &#39;px&#39;: 0,
        &#39;py&#39;: 0,
        &#39;ppx&#39;: 0,
        &#39;ppy&#39;: 0
    }
    n = len(P)
    for i in range(n):
        # Calculate the x- and y-coordinates of the of the Bezier curve given the input vector t
        C[&#39;x&#39;] = C[&#39;x&#39;] + P[i, 0] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
        C[&#39;y&#39;] = C[&#39;y&#39;] + P[i, 1] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
    for i in range(n - 1):
        # Calculate the first derivatives of the Bezier curve with respect to t, that is C_x&#39;(t) and C_y&#39;(t). Here,
        # C_x&#39;(t) is the x-component of the vector derivative dC(t)/dt, and C_y&#39;(t) is the y-component
        C[&#39;px&#39;] = C[&#39;px&#39;] + (n - 1) * (P[i + 1, 0] - P[i, 0]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
        C[&#39;py&#39;] = C[&#39;py&#39;] + (n - 1) * (P[i + 1, 1] - P[i, 1]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
    for i in range(n - 2):
        # Calculate the second derivatives of the Bezier curve with respect to t, that is C_x&#39;&#39;(t) and C_y&#39;&#39;(t). Here,
        # C_x&#39;&#39;(t) is the x-component of the vector derivative d^2C(t)/dt^2, and C_y&#39;&#39;(t) is the y-component
        C[&#39;ppx&#39;] = C[&#39;ppx&#39;] + (n - 1) * (n - 2) * (P[i + 2, 0] - 2 * P[i + 1, 0] + P[i, 0]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)
        C[&#39;ppy&#39;] = C[&#39;ppy&#39;] + (n - 1) * (n - 2) * (P[i + 2, 1] - 2 * P[i + 1, 1] + P[i, 1]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)

        # Calculate the curvature of the Bezier curve (k = kappa = 1 / R, where R is the radius of curvature)
        C[&#39;k&#39;] = (C[&#39;px&#39;] * C[&#39;ppy&#39;] - C[&#39;py&#39;] * C[&#39;ppx&#39;]) / (C[&#39;px&#39;] ** 2 + C[&#39;py&#39;] ** 2) ** (3 / 2)

    return C</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyairpar.core.airfoil.bezier"><code class="name flex">
<span>def <span class="ident">bezier</span></span>(<span>P: numpy.ndarray, nt: int) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Computes the Bézier curve through the control points <code>P</code> according to
<span><span class="MathJax_Preview">\vec{C}(t)=\sum_{i=0}^n \vec{P}_i B_{i,n}(t)</span><script type="math/tex; mode=display">\vec{C}(t)=\sum_{i=0}^n \vec{P}_i B_{i,n}(t)</script></span> where <span><span class="MathJax_Preview">B_{i,n}(t)</span><script type="math/tex">B_{i,n}(t)</script></span> is the Bernstein polynomial, given by
<span><span class="MathJax_Preview">B_{i,n}={n \choose i} t^i (1-t)^{n-i}</span><script type="math/tex; mode=display">B_{i,n}={n \choose i} t^i (1-t)^{n-i}</script></span></p>
<p>Also included are first derivative, second derivative, and curvature information. These are given by
<span><span class="MathJax_Preview">\vec{C}'(t)=n \sum_{i=0}^{n-1} (\vec{P}_{i+1} - \vec{P}_i B_{i,n-1}(t)</span><script type="math/tex; mode=display">\vec{C}'(t)=n \sum_{i=0}^{n-1} (\vec{P}_{i+1} - \vec{P}_i B_{i,n-1}(t)</script></span>
<span><span class="MathJax_Preview">\vec{C}''(t)=n(n-1) \sum_{i=0}^{n-2} (\vec{P}_{i+2}-2\vec{P}_{i+1}+\vec{P}_i) B_{i,n-2}(t)</span><script type="math/tex; mode=display">\vec{C}''(t)=n(n-1) \sum_{i=0}^{n-2} (\vec{P}_{i+2}-2\vec{P}_{i+1}+\vec{P}_i) B_{i,n-2}(t)</script></span>
<span><span class="MathJax_Preview">\kappa(t)=\frac{C'_x(t) C''_y(t) - C'_y(t) C''_x(t)}{[(C'_x)^2(t) + (C'_y)^2(t)]^{3/2}}</span><script type="math/tex; mode=display">\kappa(t)=\frac{C'_x(t) C''_y(t) - C'_y(t) C''_x(t)}{[(C'_x)^2(t) + (C'_y)^2(t)]^{3/2}}</script></span></p>
<p>Here, the <span><span class="MathJax_Preview">'</span><script type="math/tex">'</script></span> and <span><span class="MathJax_Preview">''</span><script type="math/tex">''</script></span> are the first and second derivatives with respect to <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>, not the
parameter <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>. The result of <span><span class="MathJax_Preview">\vec{C}''(t)</span><script type="math/tex">\vec{C}''(t)</script></span>, for example, is a vector with two components, <span><span class="MathJax_Preview">C''_x(t)</span><script type="math/tex">C''_x(t)</script></span>
and <span><span class="MathJax_Preview">C''_y(t)</span><script type="math/tex">C''_y(t)</script></span>.</p>
<p>An example cubic Bézier curve (order <span><span class="MathJax_Preview">n=3</span><script type="math/tex">n=3</script></span>) is shown below. Note that the curve passes through the first and
last control points and has a local slope at <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> equal to the slope of the line passing through <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span>
and <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>. Similarly, the local slope at <span><span class="MathJax_Preview">P_3</span><script type="math/tex">P_3</script></span> is equal to the slope of the line passing through
<span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span> and <span><span class="MathJax_Preview">P_3</span><script type="math/tex">P_3</script></span>. These properties of Bézier curves allow us to easily enforce <span><span class="MathJax_Preview">G^0</span><script type="math/tex">G^0</script></span> and <span><span class="MathJax_Preview">G^1</span><script type="math/tex">G^1</script></span>
continuity at Bézier curve "joints" (common endpoints of connected Bézier curves).</p>
<p><img alt="" src="bezier_curve.png"></p>
<h3 id="args">Args:</h3>
<p><code>P</code>: The control point <code>np.ndarray</code> of <code>shape=(n+1, 2)</code>, where <code>n</code> is the order of the Bézier curve and <code>n+1</code> is
the number of control points in the Bézier curve. The two columns represent the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>- and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> -components of
the control points.</p>
<p><code>nt</code>: number of points in the <code>t</code> vector (defines the resolution of the curve)</p>
<h3 id="returns">Returns:</h3>
<p>A dictionary of <code>numpy</code> arrays of <code>shape=nt</code> containing information related to the created Bézier curve:</p>
<p><span><span class="MathJax_Preview">C_x(t), C_y(t), C'_x(t), C'_y(t), C''_x(t), C''_y(t), \kappa(t)</span><script type="math/tex; mode=display">C_x(t), C_y(t), C'_x(t), C'_y(t), C''_x(t), C''_y(t), \kappa(t)</script></span>
where the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> subscripts represent the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> components of the vector-valued functions
<span><span class="MathJax_Preview">\vec{C}(t)</span><script type="math/tex">\vec{C}(t)</script></span>, <span><span class="MathJax_Preview">\vec{C}'(t)</span><script type="math/tex">\vec{C}'(t)</script></span>, and <span><span class="MathJax_Preview">\vec{C}''(t)</span><script type="math/tex">\vec{C}''(t)</script></span>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bezier(P: np.ndarray, nt: int) -&gt; dict:
    &#34;&#34;&#34;
    ### Description:

    Computes the Bézier curve through the control points `P` according to
    $$\\vec{C}(t)=\\sum_{i=0}^n \\vec{P}_i B_{i,n}(t)$$ where \\(B_{i,n}(t)\\) is the Bernstein polynomial, given by
    $$B_{i,n}={n \\choose i} t^i (1-t)^{n-i}$$

    Also included are first derivative, second derivative, and curvature information. These are given by
    $$\\vec{C}&#39;(t)=n \\sum_{i=0}^{n-1} (\\vec{P}_{i+1} - \\vec{P}_i B_{i,n-1}(t)$$
    $$\\vec{C}&#39;&#39;(t)=n(n-1) \\sum_{i=0}^{n-2} (\\vec{P}_{i+2}-2\\vec{P}_{i+1}+\\vec{P}_i) B_{i,n-2}(t)$$
    $$\\kappa(t)=\\frac{C&#39;_x(t) C&#39;&#39;_y(t) - C&#39;_y(t) C&#39;&#39;_x(t)}{[(C&#39;_x)^2(t) + (C&#39;_y)^2(t)]^{3/2}}$$

    Here, the \\(&#39;\\) and \\(&#39;&#39;\\) are the first and second derivatives with respect to \\(x\\) and \\(y\\), not the
    parameter \\(t\\). The result of \\(\\vec{C}&#39;&#39;(t)\\), for example, is a vector with two components, \\(C&#39;&#39;_x(t)\\)
    and \\(C&#39;&#39;_y(t)\\).

    An example cubic Bézier curve (order \\(n=3\\)) is shown below. Note that the curve passes through the first and
    last control points and has a local slope at \\(P_0\\) equal to the slope of the line passing through \\(P_0\\)
    and \\(P_1\\). Similarly, the local slope at \\(P_3\\) is equal to the slope of the line passing through
    \\(P_2\\) and \\(P_3\\). These properties of Bézier curves allow us to easily enforce \\(G^0\\) and \\(G^1\\)
    continuity at Bézier curve &#34;joints&#34; (common endpoints of connected Bézier curves).

    .. image:: bezier_curve.png

    ### Args:

    `P`: The control point `np.ndarray` of `shape=(n+1, 2)`, where `n` is the order of the Bézier curve and `n+1` is
    the number of control points in the Bézier curve. The two columns represent the \\(x\\)- and \\(y\\) -components of
    the control points.

    `nt`: number of points in the `t` vector (defines the resolution of the curve)

    ### Returns:

    A dictionary of `numpy` arrays of `shape=nt` containing information related to the created Bézier curve:

    $$C_x(t), C_y(t), C&#39;_x(t), C&#39;_y(t), C&#39;&#39;_x(t), C&#39;&#39;_y(t), \\kappa(t)$$
    where the \\(x\\) and \\(y\\) subscripts represent the \\(x\\) and \\(y\\) components of the vector-valued functions
    \\(\\vec{C}(t)\\), \\(\\vec{C}&#39;(t)\\), and \\(\\vec{C}&#39;&#39;(t)\\).
    &#34;&#34;&#34;

    def nCr(n_, r):
        &#34;&#34;&#34;
        ### Description:

        Simple function that computes the mathematical combination $$n \\choose r$$

        ### Args:

        `n_`: `n` written with a trailing underscore to avoid conflation with the order `n` of the Bézier curve

        `r&#39;

        ### Returns

        $$n \\choose r$$
        &#34;&#34;&#34;
        f = np.math.factorial
        return f(n_) / f(r) / f(n_ - r)

    t = np.linspace(0, 1, nt)
    C = {
        &#39;t&#39;: t,
        &#39;x&#39;: 0,
        &#39;y&#39;: 0,
        &#39;px&#39;: 0,
        &#39;py&#39;: 0,
        &#39;ppx&#39;: 0,
        &#39;ppy&#39;: 0
    }
    n = len(P)
    for i in range(n):
        # Calculate the x- and y-coordinates of the of the Bezier curve given the input vector t
        C[&#39;x&#39;] = C[&#39;x&#39;] + P[i, 0] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
        C[&#39;y&#39;] = C[&#39;y&#39;] + P[i, 1] * nCr(n - 1, i) * t ** i * (1 - t) ** (n - 1 - i)
    for i in range(n - 1):
        # Calculate the first derivatives of the Bezier curve with respect to t, that is C_x&#39;(t) and C_y&#39;(t). Here,
        # C_x&#39;(t) is the x-component of the vector derivative dC(t)/dt, and C_y&#39;(t) is the y-component
        C[&#39;px&#39;] = C[&#39;px&#39;] + (n - 1) * (P[i + 1, 0] - P[i, 0]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
        C[&#39;py&#39;] = C[&#39;py&#39;] + (n - 1) * (P[i + 1, 1] - P[i, 1]) * nCr(n - 2, i) * t ** i * (1 - t) ** (
                n - 2 - i)
    for i in range(n - 2):
        # Calculate the second derivatives of the Bezier curve with respect to t, that is C_x&#39;&#39;(t) and C_y&#39;&#39;(t). Here,
        # C_x&#39;&#39;(t) is the x-component of the vector derivative d^2C(t)/dt^2, and C_y&#39;&#39;(t) is the y-component
        C[&#39;ppx&#39;] = C[&#39;ppx&#39;] + (n - 1) * (n - 2) * (P[i + 2, 0] - 2 * P[i + 1, 0] + P[i, 0]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)
        C[&#39;ppy&#39;] = C[&#39;ppy&#39;] + (n - 1) * (n - 2) * (P[i + 2, 1] - 2 * P[i + 1, 1] + P[i, 1]) * nCr(n - 3, i) * t ** (
            i) * (1 - t) ** (n - 3 - i)

        # Calculate the curvature of the Bezier curve (k = kappa = 1 / R, where R is the radius of curvature)
        C[&#39;k&#39;] = (C[&#39;px&#39;] * C[&#39;ppy&#39;] - C[&#39;py&#39;] * C[&#39;ppx&#39;]) / (C[&#39;px&#39;] ** 2 + C[&#39;py&#39;] ** 2) ** (3 / 2)

    return C</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyairpar.core.airfoil.Airfoil"><code class="flex name class">
<span>class <span class="ident">Airfoil</span></span>
<span>(</span><span>number_coordinates: int = 100, base_airfoil_params: <a title="pyairpar.core.base_airfoil_params.BaseAirfoilParams" href="base_airfoil_params.html#pyairpar.core.base_airfoil_params.BaseAirfoilParams">BaseAirfoilParams</a> = &lt;pyairpar.core.base_airfoil_params.BaseAirfoilParams object&gt;, anchor_point_tuple: Tuple[<a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>, ...] = (), free_point_tuple: Tuple[<a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a>, ...] = (), override_parameters: list = None)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p><code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code> is the base class for Bézier-parametrized airfoil creation.</p>
<p><img alt="" src="complex_airfoil-3.png"></p>
<h3 id="args">Args:</h3>
<p><code>number_coordinates</code>: an <code>int</code> representing the number of discrete <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> - <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> coordinate pairs in each
Bézier curve. Gets passed to the <code><a title="pyairpar.core.airfoil.bezier" href="#pyairpar.core.airfoil.bezier">bezier()</a></code> function.</p>
<p><code>base_airfoil_params</code>: an instance of either the <code><a title="pyairpar.core.base_airfoil_params.BaseAirfoilParams" href="base_airfoil_params.html#pyairpar.core.base_airfoil_params.BaseAirfoilParams">BaseAirfoilParams</a></code> class or
the <code><a title="pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams" href="../symmetric/symmetric_base_airfoil_params.html#pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams">SymmetricBaseAirfoilParams</a></code> class which defines the base
set of parameters to be used</p>
<p><code>anchor_point_tuple</code>: a <code>tuple</code> of <code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code> objects. To specify a single
anchor point, use <code>(<a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>,)</code>. Default: <code>()</code></p>
<p><code>free_point_tuple</code>: a <code>tuple</code> of <code><a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a></code> objects. To specify a single free
point, use <code>(<a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a>,)</code>. Default: <code>()</code></p>
<h3 id="returns">Returns:</h3>
<p>An instance of the <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code> class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Airfoil:

    def __init__(self,
                 number_coordinates: int = 100,
                 base_airfoil_params: BaseAirfoilParams or SymmetricBaseAirfoilParams = BaseAirfoilParams(),
                 anchor_point_tuple: typing.Tuple[AnchorPoint, ...] = (),
                 free_point_tuple: typing.Tuple[FreePoint, ...] = (),
                 override_parameters: list = None
                 ):
        &#34;&#34;&#34;
        ### Description:

        `pyairpar.core.airfoil.Airfoil` is the base class for Bézier-parametrized airfoil creation.

        .. image:: complex_airfoil-3.png

        ### Args:

        `number_coordinates`: an `int` representing the number of discrete \\(x\\) - \\(y\\) coordinate pairs in each
        Bézier curve. Gets passed to the `bezier` function.

        `base_airfoil_params`: an instance of either the `pyairpar.core.base_airfoil_params.BaseAirfoilParams` class or
        the `pyairpar.symmetric.symmetric_base_airfoil_params.SymmetricBaseAirfoilParams` class which defines the base
        set of parameters to be used

        `anchor_point_tuple`: a `tuple` of `pyairpar.core.anchor_point.AnchorPoint` objects. To specify a single
        anchor point, use `(pyairpar.core.anchor_point.AnchorPoint(),)`. Default: `()`

        `free_point_tuple`: a `tuple` of `pyairpar.core.free_point.FreePoint` objects. To specify a single free
        point, use `(pyairpar.core.free_point.FreePoint(),)`. Default: `()`

        ### Returns:

        An instance of the `Airfoil` class
        &#34;&#34;&#34;

        self.nt = number_coordinates
        self.params = []
        self.base_airfoil_params = base_airfoil_params
        self.override_parameters = override_parameters

        self.override_parameter_start_idx = 0
        self.override_parameter_end_idx = self.base_airfoil_params.n_overrideable_parameters
        if self.override_parameters is not None:
            self.base_airfoil_params.override(
                self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
        self.override_parameter_start_idx += self.base_airfoil_params.n_overrideable_parameters

        self.c = base_airfoil_params.c
        self.alf = base_airfoil_params.alf
        self.R_le = base_airfoil_params.R_le
        self.L_le = base_airfoil_params.L_le
        self.r_le = base_airfoil_params.r_le
        self.phi_le = base_airfoil_params.phi_le
        self.psi1_le = base_airfoil_params.psi1_le
        self.psi2_le = base_airfoil_params.psi2_le
        self.L1_te = base_airfoil_params.L1_te
        self.L2_te = base_airfoil_params.L2_te
        self.theta1_te = base_airfoil_params.theta1_te
        self.theta2_te = base_airfoil_params.theta2_te
        self.t_te = base_airfoil_params.t_te
        self.r_te = base_airfoil_params.r_te
        self.phi_te = base_airfoil_params.phi_te
        self.dx = base_airfoil_params.dx
        self.dy = base_airfoil_params.dy

        # Ensure that all the trailing edge parameters are no longer active if the trailing edge thickness is set to 0.0
        if self.t_te.value == 0.0:
            self.r_te.active = False
            self.phi_te.active = False

        self.C = []
        self.free_points = {}
        self.param_dicts = {}
        self.coords = None
        self.non_transformed_coords = None
        self.curvature = None
        self.area = None
        self.x_thickness = None
        self.thickness = None
        self.max_thickness = None

        self.needs_update = True

        self.anchor_point_tuple = anchor_point_tuple

        if self.override_parameters is not None:
            for anchor_point in self.anchor_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    anchor_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  anchor_point.n_overrideable_parameters
                anchor_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += anchor_point.n_overrideable_parameters

        self.free_point_tuple = free_point_tuple

        if self.override_parameters is not None:
            for free_point in self.free_point_tuple:
                if self.base_airfoil_params.non_dim_by_chord:
                    free_point.length_scale_dimension = self.base_airfoil_params.c.value
                self.override_parameter_end_idx = self.override_parameter_start_idx + \
                                                  free_point.n_overrideable_parameters
                free_point.override(
                    self.override_parameters[self.override_parameter_start_idx:self.override_parameter_end_idx])
                self.override_parameter_start_idx += free_point.n_overrideable_parameters

        self.anchor_points = {&#39;te_1&#39;: self.c.value * np.array([1, 0]) + self.r_te.value * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)]),
                              &#39;le&#39;: np.array([0.0, 0.0]),
                              &#39;te_2&#39;: self.c.value * np.array([1, 0]) -
                                      (1 - self.r_te.value) * self.t_te.value *
                                      np.array([np.cos(np.pi / 2 + self.phi_te.value),
                                                np.sin(np.pi / 2 + self.phi_te.value)])}
        self.transformed_anchor_points = None
        self.anchor_point_order = [&#39;te_1&#39;, &#39;le&#39;, &#39;te_2&#39;]
        self.anchor_point_array = np.array([])

        self.N = {
            &#39;te_1&#39;: 4,
            &#39;le&#39;: 4
        }

        self.control_points = np.array([])
        self.n_control_points = len(self.control_points)

        self.g1_minus_points, self.g1_plus_points = self.init_g1_points()
        self.g2_minus_points, self.g2_plus_points = self.init_g2_points()

        self.update()

    def init_g1_points(self):
        &#34;&#34;&#34;
        ### Description:

        Initializes the &#34;g1_minus&#34; and &#34;g1_plus&#34; points for the leading edge (the neighboring control points to
        the leading edge anchor point). These points are used to enforce \\(G^1\\) continuity. &#34;Minus&#34; points refer to
        control points which occur before the anchor point in the path of the Bézier curve, and &#34;plus&#34; points refer to
        control points which occur before the anchor point.

        ### Returns:

        The neighboring control points to the leading edge anchor point as dictionaries.
        &#34;&#34;&#34;

        g1_minus_points = {
            &#39;te_2&#39;: self.anchor_points[&#39;te_2&#39;] +
                  self.L2_te.value * np.array([-np.cos(self.theta2_te.value),
                                               -np.sin(self.theta2_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] +
                  self.r_le.value * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        g1_plus_points = {
            &#39;te_1&#39;: self.anchor_points[&#39;te_1&#39;] +
                    self.L1_te.value * np.array([-np.cos(self.theta1_te.value),
                                                 np.sin(self.theta1_te.value)]),
            &#39;le&#39;: self.anchor_points[&#39;le&#39;] -
                  (1 - self.r_le.value) * self.L_le.value *
                  np.array([np.cos(np.pi / 2 + self.phi_le.value),
                            np.sin(np.pi / 2 + self.phi_le.value)])
        }

        return g1_minus_points, g1_plus_points

    def init_g2_points(self):
        &#34;&#34;&#34;
        ### Description:

        Initializes the &#34;g2_minus&#34; and &#34;g2_plus&#34; points for the leading edge (the control points two points from the
        leading edge control point). These points are used to enforce \\(G^2\\) continuity. &#34;Minus&#34; points refer to
        control points which occur before the anchor point in the path of the Bézier curve, and &#34;plus&#34; points refer to
        control points which occur before the anchor point.

        ### Returns:

        The neighboring control points to the leading edge anchor point as dictionaries.
        &#34;&#34;&#34;
        g2_minus_point_le, g2_plus_point_le = self.set_curvature_le()

        g2_minus_points = {
            &#39;le&#39;: g2_minus_point_le
        }

        g2_plus_points = {
            &#39;le&#39;: g2_plus_point_le
        }

        return g2_minus_points, g2_plus_points

    def set_slope(self, anchor_point: AnchorPoint):
        r&#34;&#34;&#34;
        ### Description:

        This is the function which enforces \(G^1\) continuity for all `pyairpar.core.anchor_point.AnchorPoint`s
        which are added. To keep the length ratios and angles defined in a &#34;nice&#34; way, the neighboring control points
        to the anchor point are defined as follows: For anchor points on the upper surface (where \((x_0,
        y_0)\) precedes the leading edge point):

        $$\begin{align*}
        \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
        (1-r)L \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix} \\
        \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
        rL \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix}
        \end{align*}$$

        For anchor points on the lower surface (where \((x_0,y_0)\) occurs further down the Bézier curve path than
        the leading edge point):

        $$\begin{align*}
        \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
        rL \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix} \\
        \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
        (1-r)L \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix}
        \end{align*}$$

        Here, \((x_{-1},y_{-1})\) represents the coordinates of the &#34;minus&#34; point (the control point before the
        leading edge point), and \((x_{+1},y_{+1})\) represents the coordinates of the &#34;plus&#34; point (the control
        point after the leading edge point). The coordinates of the anchor point itself are \((x_0,y_0)\). With
        these definitions, a ratio \(r&gt;0.5\) biases the neighboring control points toward the leading edge, and
        a ratio \(r&lt;0.5\) biases the neighboring control points toward the leading edge. A positive value of \(\phi\)
        angles the neighboring control points toward the trailing edge, and a negative value of \(\phi\) angles the
        neighboring control points toward the trailing edge. See the diagram for
        `pyairpar.core.anchor_point.AnchorPoint` for a visual description of these definitions.

        ### Returns:

        The generated neighboring control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
        &#34;&#34;&#34;
        r = anchor_point.r.value
        L = anchor_point.L.value
        phi = anchor_point.phi.value

        if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(phi), np.sin(phi)])
        else:
            self.g1_minus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(-phi), np.sin(-phi)])
            self.g1_plus_points[anchor_point.name] = \
                self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(-phi), np.sin(-phi)])
        return self.g1_minus_points[anchor_point.name], self.g1_plus_points[anchor_point.name]

    def set_curvature_le(self):
        r&#34;&#34;&#34;
        ### Description:

        See the description of `pyairpar.core.airfoil.Airfoil.set_curvature()`. This is just a special case of that
        function tailored for the leading edge of the airfoil. Here, \(\psi_1\) defines the angle of the upper
        curvature control arm, and \(\psi_2\) defines the angle of the lower curvature control arm. See also
        `pyairpar.core.base_airfoil_params.BaseAirfoilParams` for more details on the definitions of the attribute
        parameters input to this function.

        ### Returns:

        The generated curvature control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
        &#34;&#34;&#34;
        if self.R_le.value == np.inf or self.R_le.value == -np.inf:
            g2_minus_point = self.g1_minus_points[&#39;le&#39;]
            g2_plus_point = self.g1_plus_points[&#39;le&#39;]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(&#39;le&#39;) - 1]], self.N[&#39;le&#39;]
            theta1, theta2 = self.psi1_le.value, -self.psi2_le.value
            x0, y0 = self.anchor_points[&#39;le&#39;][0], self.anchor_points[&#39;le&#39;][1]

            x_m1, y_m1 = self.g1_minus_points[&#39;le&#39;][0], self.g1_minus_points[&#39;le&#39;][1]
            g2_minus_point = np.zeros(2)
            g2_minus_point[0] = x_m1 - 1 / self.R_le.value * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3/2) / (
                                1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

            x_p1, y_p1 = self.g1_plus_points[&#39;le&#39;][0], self.g1_plus_points[&#39;le&#39;][1]
            g2_plus_point = np.zeros(2)
            g2_plus_point[0] = x_p1 - 1 / self.R_le.value * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3/2) / (
                               1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

        return g2_minus_point, g2_plus_point

    def set_curvature(self, anchor_point: AnchorPoint):
        r&#34;&#34;&#34;
        ### Description:

        This is the function which enforces \(G^2\) continuity for all `pyairpar.core.anchor_point.AnchorPoint`s
        which are added. To keep the length ratios and angles defined in a &#34;nice&#34; way, the neighboring control points
        to the anchor point&#39;s slope-control points are defined as follows:

        $$
        \begin{align*}
            \begin{bmatrix} x_{-2} \\ y_{-2} \end{bmatrix} &amp;=
            \begin{cases}
                \begin{bmatrix} x_{-1} + \frac{c_1}{c_2[c_3(\tan{(\theta_1)} + y_0 - y_{-1})]}
                                \\ \tan{(\theta_1)} (x_{-2} - x_{-1}) + y_{-1} \end{bmatrix}
                                ,&amp; \theta_1 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
                \begin{bmatrix} x_{-1} \\ y_{-1} + \frac{c_1}{c_2 c_3}  \end{bmatrix},&amp; \theta_1 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
                                                                                                    R \in (-\infty,0)
                                                                                                    \cup (0,\infty) \\
                \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix},&amp; \theta_1 \in (-\infty, \infty) \wedge R =
                                                                                                            \pm \infty
            \end{cases} \\
            \begin{bmatrix} x_{+2} \\ y_{+2} \end{bmatrix} &amp;=
            \begin{cases}
                \begin{bmatrix} x_{+1} + \frac{c_4}{c_5[c_6(\tan{(\theta_2)} + y_{+1} - y_0)]}
                                \\ \tan{(\theta_2)} (x_{+2} - x_{+1}) + y_{+1} \end{bmatrix}
                                ,&amp; \theta_2 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
                \begin{bmatrix} x_{+1} \\ y_{+1} + \frac{c_4}{c_5 c_6}  \end{bmatrix},&amp; \theta_2 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
                                                                                                    R \in (-\infty,0)
                                                                                                    \cup (0,\infty) \\
                \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix},&amp; \theta_2 \in (-\infty, \infty) \wedge R =
                                                                                                            \pm \infty
            \end{cases}
        \end{align*}
        $$
        where
        $$
        \begin{align*}
        c_1 &amp;= \frac{-1}{R}[(x_0-x_{-1})^2 + (y_0-y_{-1})^2]^{3/2} \\
        c_2 &amp;= 1 - \frac{1}{n_1} \\
        c_3 &amp;= x_{-1} - x_0 \\
        c_4 &amp;= \frac{-1}{R}[(x_{+1}-x_0)^2 + (y_{+1}-y_0)^2]^{3/2} \\
        c_5 &amp;= 1 - \frac{1}{n_2} \\
        c_6 &amp;= x_0 - x_{+1}
        \end{align*}
        $$

        Here, \(n_1\) is the order of the Bézier curve preceding the anchor point, and \(n_2\) is the order of the
        Bézier curve following the anchor point. \((x_0,y_0)\) is the anchor point location, \((x_{-1},y_{-1})\)
        and \((x_{+1},y_{+1})\) are the neighboring control points, and \((x_{-2},y_{-2})\) and \((x_{+2},y_{+2})\)
        are the curvature control points. \(\theta_1\) and \(\theta_2\) are governed by the following relationships:

        $$
        \begin{align*}
            \theta_1 &amp;=
            \begin{cases}
                \psi_1 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
                \pi + \psi_2 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
                \pi - \psi_1 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
                -\psi_2 - \phi,&amp; R &lt; 0,\,\text{lower surface}
            \end{cases} \\
            \theta_2 &amp;=
            \begin{cases}
                -\psi_2 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
                \psi_1 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
                \pi + \psi_2 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
                \psi_1 - \phi,&amp; R &lt; 0,\,\text{lower surface}
            \end{cases}
        \end{align*}
        $$
        By these definitions of the curvature control arm angles, decreasing \(\psi_1\) or \(\psi_2\) from
        \(90^{\circ}\) has the effect of &#34;tucking&#34; the arms in, and increasing \(\psi_1\) or \(\psi_2\) from
        \(90^{\circ}\) has the effect of &#34;spreading&#34; the arms out. See the documentation for
        `pyairpar.core.anchor_point.AnchorPoint` for further description and a visual.

        .. note:: A value of \( R = \frac{1}{\kappa} = 0 \) (infinite curvature) is not well-defined for geometric shapes. Setting \(R = 0\) will yield an exception.

        ### Returns:

        The generated curvature control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
        &#34;&#34;&#34;
        R = anchor_point.R.value
        if R == np.inf or R == -np.inf:
            self.g2_minus_points[anchor_point.name] = self.g1_minus_points[anchor_point.name]
            self.g2_plus_points[anchor_point.name] = self.g1_plus_points[anchor_point.name]
            g2_minus_point = self.g2_minus_points[anchor_point.name]
            g2_plus_point = self.g2_plus_points[anchor_point.name]
        else:
            n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(anchor_point.name) - 1]], \
                     self.N[anchor_point.name]
            if R &gt; 0:  # If the radius of curvature is positive,
                if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
                    theta1, theta2 = anchor_point.psi1.value + anchor_point.phi.value, \
                                     -anchor_point.psi2.value + anchor_point.phi.value
                else:
                    theta2, theta1 = - anchor_point.psi1.value - anchor_point.phi.value, \
                                     np.pi + anchor_point.psi2.value - anchor_point.phi.value
            else:  # If the radius of curvature is negative,
                if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
                    theta1, theta2 = np.pi - anchor_point.psi1.value + anchor_point.phi.value, \
                                     np.pi + anchor_point.psi2.value + anchor_point.phi.value
                else:
                    theta2, theta1 = anchor_point.psi1.value - anchor_point.phi.value, \
                                     -anchor_point.psi2.value - anchor_point.phi.value
            x0, y0 = anchor_point.xy[0], anchor_point.xy[1]

            x_m1, y_m1 = self.g1_minus_points[anchor_point.name][0], self.g1_minus_points[anchor_point.name][1]
            g2_minus_point = np.zeros(2)
            c1 = - 1 / R * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3 / 2)
            c2 = 1 - 1 / n1
            c3 = x_m1 - x0
            if (theta1 - np.pi / 2) % np.pi != 0:
                g2_minus_point[0] = x_m1 + c1 / c2 / (c3 * np.tan(theta1) + y0 - y_m1)
                g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1
            else:
                g2_minus_point[0] = x_m1
                g2_minus_point[1] = y_m1 + c1 / c2 / c3

            x_p1, y_p1 = self.g1_plus_points[anchor_point.name][0], self.g1_plus_points[anchor_point.name][1]
            g2_plus_point = np.zeros(2)
            c4 = - 1 / R * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3 / 2)
            c5 = 1 - 1 / n2
            c6 = x0 - x_p1
            if (theta2 - np.pi / 2) % np.pi != 0:
                g2_plus_point[0] = x_p1 + c4 / c5 / (c6 * np.tan(theta2) + y_p1 - y0)
                g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1
            else:
                g2_plus_point[0] = x_p1
                g2_plus_point[1] = y_p1 + c4 / c5 / c6

            self.g2_minus_points[anchor_point.name] = g2_minus_point
            self.g2_plus_points[anchor_point.name] = g2_plus_point

        return g2_minus_point, g2_plus_point

    def extract_parameters(self):
        &#34;&#34;&#34;
        ### Description:

        This function extracts every parameter from the `pyairpar.core.base_airfoil_params.BaseAirfoilParams`, all the
        `pyairpar.core.anchor_point.AnchorPoint`s, and all the `pyairpar.core.free_point.FreePoint`s with
        `active=True` and `linked=False` as a `list` of parameter values.
        &#34;&#34;&#34;

        self.params = [var for var in vars(self.base_airfoil_params).values()
                       if isinstance(var, Param) and var.active and not var.linked]

        for anchor_point in self.anchor_point_tuple:

            self.params.extend([var for var in vars(anchor_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

        for free_point in self.free_point_tuple:

            self.params.extend([var for var in vars(free_point).values()
                                if isinstance(var, Param) and var.active and not var.linked])

    def order_control_points(self):
        &#34;&#34;&#34;
        ### Description:

        This function creates an array of control points based on the anchor, neighboring, and curvature control
        point dictionaries based on the `string`-based `anchor_point_order`.

        ### Returns:

        The control point array and the length of the control point array (number of control points)
        &#34;&#34;&#34;
        self.control_points = np.array([])
        for idx, anchor_point in enumerate(self.anchor_point_order):

            if idx == 0:
                self.control_points = np.append(self.control_points, self.anchor_points[anchor_point])
                self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
            else:
                if anchor_point in self.g2_minus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.g1_minus_points[anchor_point]))
                self.control_points = np.row_stack((self.control_points, self.anchor_points[anchor_point]))
                if anchor_point in self.g1_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
                if anchor_point in self.g2_plus_points:
                    self.control_points = np.row_stack((self.control_points, self.g2_plus_points[anchor_point]))

            if anchor_point in self.free_points:
                if len(self.free_points[anchor_point]) &gt; 0:
                    for fp_idx in range(len(self.free_points[anchor_point])):
                        self.control_points = \
                            np.row_stack((self.control_points, self.free_points[anchor_point][fp_idx, :]))

        self.n_control_points = len(self.control_points)
        return self.control_points, self.n_control_points

    def add_free_point(self, free_point: FreePoint):
        &#34;&#34;&#34;
        ### Description:

        Adds a free point (and 2 degrees of freedom) to a given Bézier curve (defined by the `previous_anchor_point`)

        ### Args:

        `free_point`: a `pyairpar.core.free_point.FreePoint` to add to a Bézier curve
        &#34;&#34;&#34;
        if free_point.previous_anchor_point not in self.free_points.keys():
            self.free_points[free_point.previous_anchor_point] = np.array([])
        if len(self.free_points[free_point.previous_anchor_point]) == 0:
            self.free_points[free_point.previous_anchor_point] = free_point.xy.reshape((1, 2))
        else:
            self.free_points[free_point.previous_anchor_point] = np.vstack(
                (self.free_points[free_point.previous_anchor_point], free_point.xy))

        self.needs_update = True

    def set_bezier_curve_orders(self):
        for anchor_point in self.anchor_point_tuple:
            self.N[anchor_point.name] = 5
            if anchor_point.name not in self.anchor_point_order:
                self.anchor_point_order.insert(self.anchor_point_order.index(anchor_point.previous_anchor_point) + 1,
                                               anchor_point.name)
        if self.anchor_point_order.index(&#39;te_2&#39;) - self.anchor_point_order.index(&#39;le&#39;) != 1:
            self.N[&#39;le&#39;] = 5  # Set the order of the Bézier curve after the leading edge to 5
            self.N[self.anchor_point_order[-2]] = 4  # Set the order of the last Bezier curve to 4
        for free_point in self.free_point_tuple:
            # Increment the order of the modified Bézier curve
            self.N[free_point.previous_anchor_point] += 1

    def add_anchor_point(self, anchor_point: AnchorPoint):
        &#34;&#34;&#34;
        ### Description:

        Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
        control point branch into the set of control points. `needs_update` is set to `True`.

        ### Args:

        `anchor_point`: an `pyairpar.core.anchor_point.AnchorPoint` from which to build a control point branch
        &#34;&#34;&#34;
        self.anchor_points[anchor_point.name] = anchor_point.xy
        self.set_slope(anchor_point)
        self.set_curvature(anchor_point)
        self.needs_update = True

    def add_anchor_points(self):
        &#34;&#34;&#34;
        ### Description:

        This function executes `pyairpar.core.airfoil.Airfoil.add_anchor_point()` for all the anchor points in the
        `anchor_point_tuple`. Enforces leading edge and trailing edge Bézier curve orders.
        `needs_update` is set to `True`.
        &#34;&#34;&#34;
        for anchor_point in self.anchor_point_tuple:
            self.add_anchor_point(anchor_point)
        self.needs_update = True

    def add_free_points(self):
        &#34;&#34;&#34;
        ### Description:

        This function executes `pyairpar.core.airfoil.Airfoil.add_free_point()` for all the anchor points in the
        `free_point_tuple`. `needs_update` is set to `True`.
        &#34;&#34;&#34;
        for free_point in self.free_point_tuple:
            self.add_free_point(free_point)
        self.needs_update = True

    def update_anchor_point_array(self):
        r&#34;&#34;&#34;
        ### Description:

        This function updates the `anchor_point_array` attribute of `pyairpar.core.airfoil.Airfoil`, which is a
        `np.ndarray` of `shape=(N, 2)`, where `N` is the number of anchor points in the airfoil, and the columns
        represent the \(x\) and \(y\) coordinates.
        &#34;&#34;&#34;
        for key in self.anchor_point_order:
            xy = self.anchor_points[key]
            if key == &#39;te_1&#39;:
                self.anchor_point_array = xy
            else:
                self.anchor_point_array = np.row_stack((self.anchor_point_array, xy))
        self.transformed_anchor_points = deepcopy(self.anchor_points)

    def update(self):
        r&#34;&#34;&#34;
        ### Description:

        The `update` function adds first all of the anchor points in the `anchor_point_tuple` and then all of the free
        points in the `free_point_tuple`. The parameter information is extracted. The control points are ordered
        based on the `anchor_point_order`, `name` attributes, and `previous_anchor_point` attributes. The
        `anchor_point_array` is updated based on the anchor points added. Airfoil coordinates are generated and saved.
        Rotation to the specified angle of attack
        and translation by the specified \(\Delta x\), \(\Delta y\) are applied, in that order. The Bézier
        curves are generated through the control points and the airfoil coordinates are then calculated again after
        the transformations.
        &#34;&#34;&#34;
        self.set_bezier_curve_orders()
        self.add_anchor_points()
        self.add_free_points()
        self.extract_parameters()
        self.order_control_points()
        self.update_anchor_point_array()
        self.generate_non_transformed_airfoil_coordinates()
        self.rotate(-self.alf.value)
        self.translate(self.dx.value, self.dy.value)
        self.generate_airfoil_coordinates()
        self.needs_update = False

    def override(self, parameters):
        &#34;&#34;&#34;
        ### Description:

        This function re-initializes the `Airfoil` object using the list of `override_parameters`

        ### Args:

        `parameters`: a list of `override_parameters` generated by `extract_parameters` and possibly modified.
        &#34;&#34;&#34;
        self.__init__(self.nt, self.base_airfoil_params, self.anchor_point_tuple, self.free_point_tuple,
                      override_parameters=parameters)

    def translate(self, dx: float, dy: float):
        &#34;&#34;&#34;
        ### Description:

        Translates all the control points and anchor points by \\(\\Delta x\\) and \\(\\Delta y\\).

        ### Args:

        `dx`: \\(x\\)-direction translation magnitude

        `dy`: \\(y\\)-direction translation magnitude

        ### Returns:

        The translated control point and anchor point arrays
        &#34;&#34;&#34;
        self.control_points[:, 0] += dx
        self.control_points[:, 1] += dy
        self.anchor_point_array[:, 0] += dx
        self.anchor_point_array[:, 1] += dy
        for key, anchor_point in self.transformed_anchor_points.items():
            self.transformed_anchor_points[key] = anchor_point + np.array([dx, dy])
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def rotate(self, angle: float):
        &#34;&#34;&#34;
        ### Description:

        Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.

        ### Args:

        `angle`: Angle (in radians) by which to rotate the airfoil.

        ### Returns:

        The rotated control point and anchor point arrays
        &#34;&#34;&#34;
        rot_mat = np.array([[np.cos(angle), -np.sin(angle)],
                            [np.sin(angle), np.cos(angle)]])
        self.control_points = (rot_mat @ self.control_points.T).T
        self.anchor_point_array = (rot_mat @ self.anchor_point_array.T).T
        for key, anchor_point in self.transformed_anchor_points.items():
            self.transformed_anchor_points[key] = (rot_mat @ anchor_point.T).T
        self.needs_update = True
        return self.control_points, self.anchor_point_array

    def generate_coords(self):
        &#34;&#34;&#34;
        ### Description:

        Generates the Bézier curves through the control points. Also re-casts the Bézier curve points in terms of
        airfoil coordinates by removing the points shared by joined Bézier curves. Curvature information is extracted
        from the `C` dictionary. Helper method for `generate_airfoil_coordinates()` and
        `generate_non_transformed_airfoil_coordinates()`.

        ### Returns:

        The airfoil coordinates and the curvature of the airfoil.
        &#34;&#34;&#34;
        if self.C:
            self.C = []
        P_start_idx = 0
        for idx in range(len(self.anchor_point_order) - 1):
            P_length = self.N[self.anchor_point_order[idx]] + 1
            P_end_idx = P_start_idx + P_length
            P = self.control_points[P_start_idx:P_end_idx, :]
            C = bezier(P, self.nt)
            self.C.append(C)
            P_start_idx = P_end_idx - 1
        coords = np.array([])
        curvature = np.array([])
        for idx in range(len(self.C)):
            if idx == 0:
                coords = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;y&#39;]))
                curvature = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;k&#39;]))
            else:
                coords = np.row_stack((coords, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;y&#39;][1:]))))
                curvature = np.row_stack((curvature, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;k&#39;][1:]))))
        return coords, curvature

    def generate_airfoil_coordinates(self):
        &#34;&#34;&#34;
        ### Description:

        Runs the `generate_coords()` method after the rotation and translation steps and saves the information to
        the `coords` and `curvature` attributes of `Airfoil`. Used in `Airfoil.update()`.

        ### Returns:

        The airfoil coordinates, the `C` dictionary of Bézier curve information, and the curvature.
        &#34;&#34;&#34;
        coords, curvature = self.generate_coords()
        self.coords = coords
        self.curvature = curvature
        return self.coords, self.C, self.curvature

    def generate_non_transformed_airfoil_coordinates(self):
        &#34;&#34;&#34;
        ### Description:

        Runs the `generate_coords()` method before the rotation and translation steps and saves the information to the
        `non_transformed_coords` attribute of `Airfoil`. Used in `Airfoil.update()`.

        ### Returns:

        The coordinates of the airfoil before rotation and translation.
        &#34;&#34;&#34;
        coords, _ = self.generate_coords()
        self.non_transformed_coords = coords
        return self.non_transformed_coords

    def compute_area(self):
        &#34;&#34;&#34;
        ### Description:

        Computes the area of the airfoil as the area of a many-sided polygon enclosed by the airfoil coordinates using
        the [shapely](https://shapely.readthedocs.io/en/stable/manual.html) library.

        ### Returns:
        The area of the airfoil
        &#34;&#34;&#34;
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        polygon = Polygon(points_shapely)
        area = polygon.area
        self.area = area
        return area

    def check_self_intersection(self):
        &#34;&#34;&#34;
        ### Description:

        Determines whether the airfoil intersects itself using the `is_simple()` function of the
        [`shapely`](https://shapely.readthedocs.io/en/stable/manual.html) library.

        ### Returns:

        A `bool` value describing whether the airfoil intersects itself
        &#34;&#34;&#34;
        if self.needs_update:
            self.update()
        points_shapely = list(map(tuple, self.coords))
        line_string = LineString(points_shapely)
        is_simple = line_string.is_simple
        return not is_simple

    def compute_thickness(self, n_lines: int = 201):
        r&#34;&#34;&#34;
        ### Description:

        Calculates the thickness distribution and maximum thickness of the airfoil.

        ### Args:

        `n_lines`: Optional `int` describing the number of lines evenly spaced along the chordline produced to
        determine the thickness distribution. Default: `201`.

        ### Returns:

        The list of \(x\)-values used for the thickness distribution calculation, the thickness distribution, and the
        maximum value of the thickness distribution.
        &#34;&#34;&#34;
        points_shapely = list(map(tuple, self.non_transformed_coords))
        airfoil_line_string = LineString(points_shapely)
        x_thickness = np.linspace(0.0, self.c.value, n_lines)
        thickness = []
        for idx in range(n_lines):
            line_string = LineString([(x_thickness[idx], -1), (x_thickness[idx], 1)])
            x_inters = line_string.intersection(airfoil_line_string)
            if x_inters.is_empty:
                thickness.append(0.0)
            else:
                thickness.append(x_inters.convex_hull.length)
        self.x_thickness = x_thickness
        self.thickness = thickness
        self.max_thickness = max(thickness)
        return self.x_thickness, self.thickness, self.max_thickness

    def plot(self, plot_what: typing.Tuple[str, ...], fig: Figure = None, axs: Axes = None, show_plot: bool = True,
             save_plot: bool = False, save_path: str = None, plot_kwargs: typing.List[dict] = None,
             show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5,
             tight_layout: bool = True, axis_equal: bool = True):
        r&#34;&#34;&#34;
        ### Description:

        A variety of airfoil plotting options using [`matplotlib`](https://matplotlib.org/). Many wrapper options
        are available here, but custom plots can also be created directly from the `coords`, `curvature`, `C`,
        `control_points`, and `anchor_point_array` attributes of the `Airfoil` class.

        ### Args:

        `plot_what`: One or more of `&#34;airfoil&#34;`, `&#34;anchor-point-skeleton&#34;`, `&#34;control-point-skeleton&#34;`,
        `&#34;chordline&#34;`, `&#34;R-circles&#34;`, or `&#34;curvature&#34;`.

        `fig`: The
        [`matplotlib.figure.Figure`](https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure)
        object as a canvas input. New `Figure` is created if `None`. Default: `None`.

        `axs`: The
        [`matplotlib.axes.Axes`](https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class)
        object as a axes input. New `Axes` is created if `None`. Default: `None`.

        `show_plot`: Whether to show the plot (`bool`). Default: `True`.

        `save_plot`: Whether to save the plot (`bool`). Default: `False`.

        `save_path`: A `str` describing the root directory, filename, and image extension of the path to save. Only
        used if `save_plot` is `True`. Default: `None`.

        `plot_kwargs`: A list of dictionaries with [`matplotlib`](https://matplotlib.org/) keyword arguments to be
        unpacked and applied to each Bézier curve element-by-element. Default: `None`.

        `show_title`: Whether to show a title describing the airfoil chord length, angle of attack, and area (`bool`).
        Default: `True`.

        `show_legend`: Whether to show the legend (`bool`). Default: `True`.

        `figwidth`: The width of the figure, in inches (`float`). Default: `10.0`.

        `figheight`: The height of the figure, in inches (`float`). Default: `2.5`.

        `tight_layout`: Whether to tighten the margins around the plot (`bool`). Default: `True`.

        `axis_equal`: Whether to set the aspect ratio of the plot to equal \(x\) and \(y\) (`bool`). Default: `True`.

        ### Returns:

        A tuple of the
        [`matplotlib.figure.Figure`](https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure)
        object and the
        [`matplotlib.axes.Axes`](https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class)
        object used for plotting
        &#34;&#34;&#34;
        if self.needs_update:
            self.update()
        if fig is None and axs is None:
            fig, axs = plt.subplots(1, 1)

        for what_to_plot in plot_what:

            if what_to_plot == &#39;airfoil&#39;:
                for idx, C in enumerate(self.C):
                    if plot_kwargs is None:
                        if idx == 0:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;, label=&#39;airfoil&#39;)
                        else:
                            axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;)
                    else:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], **plot_kwargs[idx])

            if what_to_plot == &#39;anchor-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], &#39;:x&#39;, color=&#39;black&#39;,
                             label=&#39;anchor point skeleton&#39;)
                else:
                    axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], **plot_kwargs)

            if what_to_plot == &#39;control-point-skeleton&#39;:
                if plot_kwargs is None:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], &#39;--*&#39;, color=&#39;grey&#39;,
                             label=&#39;control point skeleton&#39;)
                else:
                    axs.plot(self.control_points[:, 0], self.control_points[:, 1], **plot_kwargs)
            if what_to_plot == &#39;chordline&#39;:
                if plot_kwargs is None:
                    axs.plot(np.array([0 + self.dx.value, self.c.value * np.cos(self.alf.value) + self.dx.value]),
                             np.array([0 + self.dy.value, -self.c.value * np.sin(self.alf.value) + self.dy.value]),
                             &#39;-.&#39;, color=&#39;indianred&#39;, label=&#39;chordline&#39;)
                else:
                    axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                             np.array([0, -self.c.value * np.sin(self.alf.value)]), **plot_kwargs)
            if what_to_plot == &#39;R-circles&#39;:
                line = [[0 + self.dx.value, self.R_le.value *
                         np.cos(self.phi_le.value - self.alf.value) + self.dx.value],
                        [0 + self.dy.value, self.R_le.value *
                         np.sin(self.phi_le.value - self.alf.value) + self.dy.value]]
                circle = plt.Circle((line[0][1], line[1][1]), self.R_le.value, fill=False, color=&#39;gold&#39;,
                                    label=&#39;R circle&#39;)
                axs.plot(line[0], line[1], color=&#39;gold&#39;)
                axs.add_patch(circle)
                for anchor_point in self.anchor_point_tuple:
                    xy = self.anchor_point_array[self.anchor_point_order.index(anchor_point.name), :]
                    if self.anchor_point_order.index(anchor_point.name) &gt; self.anchor_point_order.index(&#39;le&#39;):
                        perp_angle = np.pi / 2
                        phi = -anchor_point.phi.value
                    else:
                        perp_angle = -np.pi / 2
                        phi = anchor_point.phi.value
                    line = np.array([xy, xy + anchor_point.R.value *
                                     np.array([np.cos(phi - self.alf.value + perp_angle),
                                               np.sin(phi - self.alf.value + perp_angle)])])
                    circle = plt.Circle((line[1, 0], line[1, 1]), anchor_point.R.value, fill=False, color=&#39;gold&#39;)
                    axs.plot(line[:, 0], line[:, 1], color=&#39;gold&#39;)
                    axs.add_patch(circle)
            if what_to_plot == &#39;curvature&#39;:
                if plot_kwargs is None:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], color=&#39;cornflowerblue&#39;, label=&#39;curvature&#39;)
                else:
                    axs.plot(self.curvature[:, 0], self.curvature[:, 1], **plot_kwargs)

        if axis_equal:
            axs.set_aspect(&#39;equal&#39;, &#39;box&#39;)
        if show_title:
            area = self.compute_area()
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$, $A={area:.5f}$&#39;)
        else:
            fig.suptitle(
                fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$&#39;)
        if tight_layout:
            fig.tight_layout()
        fig.set_figwidth(figwidth)
        fig.set_figheight(figheight)
        if show_legend:
            axs.legend()
        if save_plot:
            fig.savefig(save_path)
        if show_plot:
            plt.show()
        return fig, axs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyairpar.symmetric.symmetric_airfoil.SymmetricAirfoil" href="../symmetric/symmetric_airfoil.html#pyairpar.symmetric.symmetric_airfoil.SymmetricAirfoil">SymmetricAirfoil</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyairpar.core.airfoil.Airfoil.add_anchor_point"><code class="name flex">
<span>def <span class="ident">add_anchor_point</span></span>(<span>self, anchor_point: <a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
control point branch into the set of control points. <code>needs_update</code> is set to <code>True</code>.</p>
<h3 id="args">Args:</h3>
<p><code>anchor_point</code>: an <code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code> from which to build a control point branch</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_anchor_point(self, anchor_point: AnchorPoint):
    &#34;&#34;&#34;
    ### Description:

    Adds an anchor point between two anchor points, builds the associated control point branch, and inserts the
    control point branch into the set of control points. `needs_update` is set to `True`.

    ### Args:

    `anchor_point`: an `pyairpar.core.anchor_point.AnchorPoint` from which to build a control point branch
    &#34;&#34;&#34;
    self.anchor_points[anchor_point.name] = anchor_point.xy
    self.set_slope(anchor_point)
    self.set_curvature(anchor_point)
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.add_anchor_points"><code class="name flex">
<span>def <span class="ident">add_anchor_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This function executes <code><a title="pyairpar.core.airfoil.Airfoil.add_anchor_point" href="#pyairpar.core.airfoil.Airfoil.add_anchor_point">Airfoil.add_anchor_point()</a></code> for all the anchor points in the
<code>anchor_point_tuple</code>. Enforces leading edge and trailing edge Bézier curve orders.
<code>needs_update</code> is set to <code>True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_anchor_points(self):
    &#34;&#34;&#34;
    ### Description:

    This function executes `pyairpar.core.airfoil.Airfoil.add_anchor_point()` for all the anchor points in the
    `anchor_point_tuple`. Enforces leading edge and trailing edge Bézier curve orders.
    `needs_update` is set to `True`.
    &#34;&#34;&#34;
    for anchor_point in self.anchor_point_tuple:
        self.add_anchor_point(anchor_point)
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.add_free_point"><code class="name flex">
<span>def <span class="ident">add_free_point</span></span>(<span>self, free_point: <a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Adds a free point (and 2 degrees of freedom) to a given Bézier curve (defined by the <code>previous_anchor_point</code>)</p>
<h3 id="args">Args:</h3>
<p><code>free_point</code>: a <code><a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a></code> to add to a Bézier curve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_free_point(self, free_point: FreePoint):
    &#34;&#34;&#34;
    ### Description:

    Adds a free point (and 2 degrees of freedom) to a given Bézier curve (defined by the `previous_anchor_point`)

    ### Args:

    `free_point`: a `pyairpar.core.free_point.FreePoint` to add to a Bézier curve
    &#34;&#34;&#34;
    if free_point.previous_anchor_point not in self.free_points.keys():
        self.free_points[free_point.previous_anchor_point] = np.array([])
    if len(self.free_points[free_point.previous_anchor_point]) == 0:
        self.free_points[free_point.previous_anchor_point] = free_point.xy.reshape((1, 2))
    else:
        self.free_points[free_point.previous_anchor_point] = np.vstack(
            (self.free_points[free_point.previous_anchor_point], free_point.xy))

    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.add_free_points"><code class="name flex">
<span>def <span class="ident">add_free_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This function executes <code><a title="pyairpar.core.airfoil.Airfoil.add_free_point" href="#pyairpar.core.airfoil.Airfoil.add_free_point">Airfoil.add_free_point()</a></code> for all the anchor points in the
<code>free_point_tuple</code>. <code>needs_update</code> is set to <code>True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_free_points(self):
    &#34;&#34;&#34;
    ### Description:

    This function executes `pyairpar.core.airfoil.Airfoil.add_free_point()` for all the anchor points in the
    `free_point_tuple`. `needs_update` is set to `True`.
    &#34;&#34;&#34;
    for free_point in self.free_point_tuple:
        self.add_free_point(free_point)
    self.needs_update = True</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.check_self_intersection"><code class="name flex">
<span>def <span class="ident">check_self_intersection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Determines whether the airfoil intersects itself using the <code>is_simple()</code> function of the
<a href="https://shapely.readthedocs.io/en/stable/manual.html"><code>shapely</code></a> library.</p>
<h3 id="returns">Returns:</h3>
<p>A <code>bool</code> value describing whether the airfoil intersects itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_self_intersection(self):
    &#34;&#34;&#34;
    ### Description:

    Determines whether the airfoil intersects itself using the `is_simple()` function of the
    [`shapely`](https://shapely.readthedocs.io/en/stable/manual.html) library.

    ### Returns:

    A `bool` value describing whether the airfoil intersects itself
    &#34;&#34;&#34;
    if self.needs_update:
        self.update()
    points_shapely = list(map(tuple, self.coords))
    line_string = LineString(points_shapely)
    is_simple = line_string.is_simple
    return not is_simple</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.compute_area"><code class="name flex">
<span>def <span class="ident">compute_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Computes the area of the airfoil as the area of a many-sided polygon enclosed by the airfoil coordinates using
the <a href="https://shapely.readthedocs.io/en/stable/manual.html">shapely</a> library.</p>
<h3 id="returns">Returns:</h3>
<p>The area of the airfoil</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_area(self):
    &#34;&#34;&#34;
    ### Description:

    Computes the area of the airfoil as the area of a many-sided polygon enclosed by the airfoil coordinates using
    the [shapely](https://shapely.readthedocs.io/en/stable/manual.html) library.

    ### Returns:
    The area of the airfoil
    &#34;&#34;&#34;
    if self.needs_update:
        self.update()
    points_shapely = list(map(tuple, self.coords))
    polygon = Polygon(points_shapely)
    area = polygon.area
    self.area = area
    return area</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.compute_thickness"><code class="name flex">
<span>def <span class="ident">compute_thickness</span></span>(<span>self, n_lines: int = 201)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Calculates the thickness distribution and maximum thickness of the airfoil.</p>
<h3 id="args">Args:</h3>
<p><code>n_lines</code>: Optional <code>int</code> describing the number of lines evenly spaced along the chordline produced to
determine the thickness distribution. Default: <code>201</code>.</p>
<h3 id="returns">Returns:</h3>
<p>The list of <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>-values used for the thickness distribution calculation, the thickness distribution, and the
maximum value of the thickness distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_thickness(self, n_lines: int = 201):
    r&#34;&#34;&#34;
    ### Description:

    Calculates the thickness distribution and maximum thickness of the airfoil.

    ### Args:

    `n_lines`: Optional `int` describing the number of lines evenly spaced along the chordline produced to
    determine the thickness distribution. Default: `201`.

    ### Returns:

    The list of \(x\)-values used for the thickness distribution calculation, the thickness distribution, and the
    maximum value of the thickness distribution.
    &#34;&#34;&#34;
    points_shapely = list(map(tuple, self.non_transformed_coords))
    airfoil_line_string = LineString(points_shapely)
    x_thickness = np.linspace(0.0, self.c.value, n_lines)
    thickness = []
    for idx in range(n_lines):
        line_string = LineString([(x_thickness[idx], -1), (x_thickness[idx], 1)])
        x_inters = line_string.intersection(airfoil_line_string)
        if x_inters.is_empty:
            thickness.append(0.0)
        else:
            thickness.append(x_inters.convex_hull.length)
    self.x_thickness = x_thickness
    self.thickness = thickness
    self.max_thickness = max(thickness)
    return self.x_thickness, self.thickness, self.max_thickness</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.extract_parameters"><code class="name flex">
<span>def <span class="ident">extract_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This function extracts every parameter from the <code><a title="pyairpar.core.base_airfoil_params.BaseAirfoilParams" href="base_airfoil_params.html#pyairpar.core.base_airfoil_params.BaseAirfoilParams">BaseAirfoilParams</a></code>, all the
<code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code>s, and all the <code><a title="pyairpar.core.free_point.FreePoint" href="free_point.html#pyairpar.core.free_point.FreePoint">FreePoint</a></code>s with
<code>active=True</code> and <code>linked=False</code> as a <code>list</code> of parameter values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_parameters(self):
    &#34;&#34;&#34;
    ### Description:

    This function extracts every parameter from the `pyairpar.core.base_airfoil_params.BaseAirfoilParams`, all the
    `pyairpar.core.anchor_point.AnchorPoint`s, and all the `pyairpar.core.free_point.FreePoint`s with
    `active=True` and `linked=False` as a `list` of parameter values.
    &#34;&#34;&#34;

    self.params = [var for var in vars(self.base_airfoil_params).values()
                   if isinstance(var, Param) and var.active and not var.linked]

    for anchor_point in self.anchor_point_tuple:

        self.params.extend([var for var in vars(anchor_point).values()
                            if isinstance(var, Param) and var.active and not var.linked])

    for free_point in self.free_point_tuple:

        self.params.extend([var for var in vars(free_point).values()
                            if isinstance(var, Param) and var.active and not var.linked])</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.generate_airfoil_coordinates"><code class="name flex">
<span>def <span class="ident">generate_airfoil_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Runs the <code>generate_coords()</code> method after the rotation and translation steps and saves the information to
the <code>coords</code> and <code>curvature</code> attributes of <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code>. Used in <code><a title="pyairpar.core.airfoil.Airfoil.update" href="#pyairpar.core.airfoil.Airfoil.update">Airfoil.update()</a></code>.</p>
<h3 id="returns">Returns:</h3>
<p>The airfoil coordinates, the <code>C</code> dictionary of Bézier curve information, and the curvature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_airfoil_coordinates(self):
    &#34;&#34;&#34;
    ### Description:

    Runs the `generate_coords()` method after the rotation and translation steps and saves the information to
    the `coords` and `curvature` attributes of `Airfoil`. Used in `Airfoil.update()`.

    ### Returns:

    The airfoil coordinates, the `C` dictionary of Bézier curve information, and the curvature.
    &#34;&#34;&#34;
    coords, curvature = self.generate_coords()
    self.coords = coords
    self.curvature = curvature
    return self.coords, self.C, self.curvature</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.generate_coords"><code class="name flex">
<span>def <span class="ident">generate_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Generates the Bézier curves through the control points. Also re-casts the Bézier curve points in terms of
airfoil coordinates by removing the points shared by joined Bézier curves. Curvature information is extracted
from the <code>C</code> dictionary. Helper method for <code>generate_airfoil_coordinates()</code> and
<code>generate_non_transformed_airfoil_coordinates()</code>.</p>
<h3 id="returns">Returns:</h3>
<p>The airfoil coordinates and the curvature of the airfoil.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_coords(self):
    &#34;&#34;&#34;
    ### Description:

    Generates the Bézier curves through the control points. Also re-casts the Bézier curve points in terms of
    airfoil coordinates by removing the points shared by joined Bézier curves. Curvature information is extracted
    from the `C` dictionary. Helper method for `generate_airfoil_coordinates()` and
    `generate_non_transformed_airfoil_coordinates()`.

    ### Returns:

    The airfoil coordinates and the curvature of the airfoil.
    &#34;&#34;&#34;
    if self.C:
        self.C = []
    P_start_idx = 0
    for idx in range(len(self.anchor_point_order) - 1):
        P_length = self.N[self.anchor_point_order[idx]] + 1
        P_end_idx = P_start_idx + P_length
        P = self.control_points[P_start_idx:P_end_idx, :]
        C = bezier(P, self.nt)
        self.C.append(C)
        P_start_idx = P_end_idx - 1
    coords = np.array([])
    curvature = np.array([])
    for idx in range(len(self.C)):
        if idx == 0:
            coords = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;y&#39;]))
            curvature = np.column_stack((self.C[idx][&#39;x&#39;], self.C[idx][&#39;k&#39;]))
        else:
            coords = np.row_stack((coords, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;y&#39;][1:]))))
            curvature = np.row_stack((curvature, np.column_stack((self.C[idx][&#39;x&#39;][1:], self.C[idx][&#39;k&#39;][1:]))))
    return coords, curvature</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.generate_non_transformed_airfoil_coordinates"><code class="name flex">
<span>def <span class="ident">generate_non_transformed_airfoil_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Runs the <code>generate_coords()</code> method before the rotation and translation steps and saves the information to the
<code>non_transformed_coords</code> attribute of <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code>. Used in <code><a title="pyairpar.core.airfoil.Airfoil.update" href="#pyairpar.core.airfoil.Airfoil.update">Airfoil.update()</a></code>.</p>
<h3 id="returns">Returns:</h3>
<p>The coordinates of the airfoil before rotation and translation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_non_transformed_airfoil_coordinates(self):
    &#34;&#34;&#34;
    ### Description:

    Runs the `generate_coords()` method before the rotation and translation steps and saves the information to the
    `non_transformed_coords` attribute of `Airfoil`. Used in `Airfoil.update()`.

    ### Returns:

    The coordinates of the airfoil before rotation and translation.
    &#34;&#34;&#34;
    coords, _ = self.generate_coords()
    self.non_transformed_coords = coords
    return self.non_transformed_coords</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.init_g1_points"><code class="name flex">
<span>def <span class="ident">init_g1_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Initializes the "g1_minus" and "g1_plus" points for the leading edge (the neighboring control points to
the leading edge anchor point). These points are used to enforce <span><span class="MathJax_Preview">G^1</span><script type="math/tex">G^1</script></span> continuity. "Minus" points refer to
control points which occur before the anchor point in the path of the Bézier curve, and "plus" points refer to
control points which occur before the anchor point.</p>
<h3 id="returns">Returns:</h3>
<p>The neighboring control points to the leading edge anchor point as dictionaries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_g1_points(self):
    &#34;&#34;&#34;
    ### Description:

    Initializes the &#34;g1_minus&#34; and &#34;g1_plus&#34; points for the leading edge (the neighboring control points to
    the leading edge anchor point). These points are used to enforce \\(G^1\\) continuity. &#34;Minus&#34; points refer to
    control points which occur before the anchor point in the path of the Bézier curve, and &#34;plus&#34; points refer to
    control points which occur before the anchor point.

    ### Returns:

    The neighboring control points to the leading edge anchor point as dictionaries.
    &#34;&#34;&#34;

    g1_minus_points = {
        &#39;te_2&#39;: self.anchor_points[&#39;te_2&#39;] +
              self.L2_te.value * np.array([-np.cos(self.theta2_te.value),
                                           -np.sin(self.theta2_te.value)]),
        &#39;le&#39;: self.anchor_points[&#39;le&#39;] +
              self.r_le.value * self.L_le.value *
              np.array([np.cos(np.pi / 2 + self.phi_le.value),
                        np.sin(np.pi / 2 + self.phi_le.value)])
    }

    g1_plus_points = {
        &#39;te_1&#39;: self.anchor_points[&#39;te_1&#39;] +
                self.L1_te.value * np.array([-np.cos(self.theta1_te.value),
                                             np.sin(self.theta1_te.value)]),
        &#39;le&#39;: self.anchor_points[&#39;le&#39;] -
              (1 - self.r_le.value) * self.L_le.value *
              np.array([np.cos(np.pi / 2 + self.phi_le.value),
                        np.sin(np.pi / 2 + self.phi_le.value)])
    }

    return g1_minus_points, g1_plus_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.init_g2_points"><code class="name flex">
<span>def <span class="ident">init_g2_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Initializes the "g2_minus" and "g2_plus" points for the leading edge (the control points two points from the
leading edge control point). These points are used to enforce <span><span class="MathJax_Preview">G^2</span><script type="math/tex">G^2</script></span> continuity. "Minus" points refer to
control points which occur before the anchor point in the path of the Bézier curve, and "plus" points refer to
control points which occur before the anchor point.</p>
<h3 id="returns">Returns:</h3>
<p>The neighboring control points to the leading edge anchor point as dictionaries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_g2_points(self):
    &#34;&#34;&#34;
    ### Description:

    Initializes the &#34;g2_minus&#34; and &#34;g2_plus&#34; points for the leading edge (the control points two points from the
    leading edge control point). These points are used to enforce \\(G^2\\) continuity. &#34;Minus&#34; points refer to
    control points which occur before the anchor point in the path of the Bézier curve, and &#34;plus&#34; points refer to
    control points which occur before the anchor point.

    ### Returns:

    The neighboring control points to the leading edge anchor point as dictionaries.
    &#34;&#34;&#34;
    g2_minus_point_le, g2_plus_point_le = self.set_curvature_le()

    g2_minus_points = {
        &#39;le&#39;: g2_minus_point_le
    }

    g2_plus_points = {
        &#39;le&#39;: g2_plus_point_le
    }

    return g2_minus_points, g2_plus_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.order_control_points"><code class="name flex">
<span>def <span class="ident">order_control_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This function creates an array of control points based on the anchor, neighboring, and curvature control
point dictionaries based on the <code>string</code>-based <code>anchor_point_order</code>.</p>
<h3 id="returns">Returns:</h3>
<p>The control point array and the length of the control point array (number of control points)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_control_points(self):
    &#34;&#34;&#34;
    ### Description:

    This function creates an array of control points based on the anchor, neighboring, and curvature control
    point dictionaries based on the `string`-based `anchor_point_order`.

    ### Returns:

    The control point array and the length of the control point array (number of control points)
    &#34;&#34;&#34;
    self.control_points = np.array([])
    for idx, anchor_point in enumerate(self.anchor_point_order):

        if idx == 0:
            self.control_points = np.append(self.control_points, self.anchor_points[anchor_point])
            self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
        else:
            if anchor_point in self.g2_minus_points:
                self.control_points = np.row_stack((self.control_points, self.g2_minus_points[anchor_point]))
            self.control_points = np.row_stack((self.control_points, self.g1_minus_points[anchor_point]))
            self.control_points = np.row_stack((self.control_points, self.anchor_points[anchor_point]))
            if anchor_point in self.g1_plus_points:
                self.control_points = np.row_stack((self.control_points, self.g1_plus_points[anchor_point]))
            if anchor_point in self.g2_plus_points:
                self.control_points = np.row_stack((self.control_points, self.g2_plus_points[anchor_point]))

        if anchor_point in self.free_points:
            if len(self.free_points[anchor_point]) &gt; 0:
                for fp_idx in range(len(self.free_points[anchor_point])):
                    self.control_points = \
                        np.row_stack((self.control_points, self.free_points[anchor_point][fp_idx, :]))

    self.n_control_points = len(self.control_points)
    return self.control_points, self.n_control_points</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.override"><code class="name flex">
<span>def <span class="ident">override</span></span>(<span>self, parameters)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This function re-initializes the <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code> object using the list of <code>override_parameters</code></p>
<h3 id="args">Args:</h3>
<p><code>parameters</code>: a list of <code>override_parameters</code> generated by <code>extract_parameters</code> and possibly modified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override(self, parameters):
    &#34;&#34;&#34;
    ### Description:

    This function re-initializes the `Airfoil` object using the list of `override_parameters`

    ### Args:

    `parameters`: a list of `override_parameters` generated by `extract_parameters` and possibly modified.
    &#34;&#34;&#34;
    self.__init__(self.nt, self.base_airfoil_params, self.anchor_point_tuple, self.free_point_tuple,
                  override_parameters=parameters)</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot_what: Tuple[str, ...], fig: matplotlib.figure.Figure = None, axs: matplotlib.axes._axes.Axes = None, show_plot: bool = True, save_plot: bool = False, save_path: str = None, plot_kwargs: List[dict] = None, show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5, tight_layout: bool = True, axis_equal: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>A variety of airfoil plotting options using <a href="https://matplotlib.org/"><code>matplotlib</code></a>. Many wrapper options
are available here, but custom plots can also be created directly from the <code>coords</code>, <code>curvature</code>, <code>C</code>,
<code>control_points</code>, and <code>anchor_point_array</code> attributes of the <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code> class.</p>
<h3 id="args">Args:</h3>
<p><code>plot_what</code>: One or more of <code>"airfoil"</code>, <code>"anchor-point-skeleton"</code>, <code>"control-point-skeleton"</code>,
<code>"chordline"</code>, <code>"R-circles"</code>, or <code>"curvature"</code>.</p>
<p><code>fig</code>: The
<a href="https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a>
object as a canvas input. New <code>Figure</code> is created if <code>None</code>. Default: <code>None</code>.</p>
<p><code>axs</code>: The
<a href="https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class"><code>matplotlib.axes.Axes</code></a>
object as a axes input. New <code>Axes</code> is created if <code>None</code>. Default: <code>None</code>.</p>
<p><code>show_plot</code>: Whether to show the plot (<code>bool</code>). Default: <code>True</code>.</p>
<p><code>save_plot</code>: Whether to save the plot (<code>bool</code>). Default: <code>False</code>.</p>
<p><code>save_path</code>: A <code>str</code> describing the root directory, filename, and image extension of the path to save. Only
used if <code>save_plot</code> is <code>True</code>. Default: <code>None</code>.</p>
<p><code>plot_kwargs</code>: A list of dictionaries with <a href="https://matplotlib.org/"><code>matplotlib</code></a> keyword arguments to be
unpacked and applied to each Bézier curve element-by-element. Default: <code>None</code>.</p>
<p><code>show_title</code>: Whether to show a title describing the airfoil chord length, angle of attack, and area (<code>bool</code>).
Default: <code>True</code>.</p>
<p><code>show_legend</code>: Whether to show the legend (<code>bool</code>). Default: <code>True</code>.</p>
<p><code>figwidth</code>: The width of the figure, in inches (<code>float</code>). Default: <code>10.0</code>.</p>
<p><code>figheight</code>: The height of the figure, in inches (<code>float</code>). Default: <code>2.5</code>.</p>
<p><code>tight_layout</code>: Whether to tighten the margins around the plot (<code>bool</code>). Default: <code>True</code>.</p>
<p><code>axis_equal</code>: Whether to set the aspect ratio of the plot to equal <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> (<code>bool</code>). Default: <code>True</code>.</p>
<h3 id="returns">Returns:</h3>
<p>A tuple of the
<a href="https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure"><code>matplotlib.figure.Figure</code></a>
object and the
<a href="https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class"><code>matplotlib.axes.Axes</code></a>
object used for plotting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, plot_what: typing.Tuple[str, ...], fig: Figure = None, axs: Axes = None, show_plot: bool = True,
         save_plot: bool = False, save_path: str = None, plot_kwargs: typing.List[dict] = None,
         show_title: bool = True, show_legend: bool = True, figwidth: float = 10.0, figheight: float = 2.5,
         tight_layout: bool = True, axis_equal: bool = True):
    r&#34;&#34;&#34;
    ### Description:

    A variety of airfoil plotting options using [`matplotlib`](https://matplotlib.org/). Many wrapper options
    are available here, but custom plots can also be created directly from the `coords`, `curvature`, `C`,
    `control_points`, and `anchor_point_array` attributes of the `Airfoil` class.

    ### Args:

    `plot_what`: One or more of `&#34;airfoil&#34;`, `&#34;anchor-point-skeleton&#34;`, `&#34;control-point-skeleton&#34;`,
    `&#34;chordline&#34;`, `&#34;R-circles&#34;`, or `&#34;curvature&#34;`.

    `fig`: The
    [`matplotlib.figure.Figure`](https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure)
    object as a canvas input. New `Figure` is created if `None`. Default: `None`.

    `axs`: The
    [`matplotlib.axes.Axes`](https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class)
    object as a axes input. New `Axes` is created if `None`. Default: `None`.

    `show_plot`: Whether to show the plot (`bool`). Default: `True`.

    `save_plot`: Whether to save the plot (`bool`). Default: `False`.

    `save_path`: A `str` describing the root directory, filename, and image extension of the path to save. Only
    used if `save_plot` is `True`. Default: `None`.

    `plot_kwargs`: A list of dictionaries with [`matplotlib`](https://matplotlib.org/) keyword arguments to be
    unpacked and applied to each Bézier curve element-by-element. Default: `None`.

    `show_title`: Whether to show a title describing the airfoil chord length, angle of attack, and area (`bool`).
    Default: `True`.

    `show_legend`: Whether to show the legend (`bool`). Default: `True`.

    `figwidth`: The width of the figure, in inches (`float`). Default: `10.0`.

    `figheight`: The height of the figure, in inches (`float`). Default: `2.5`.

    `tight_layout`: Whether to tighten the margins around the plot (`bool`). Default: `True`.

    `axis_equal`: Whether to set the aspect ratio of the plot to equal \(x\) and \(y\) (`bool`). Default: `True`.

    ### Returns:

    A tuple of the
    [`matplotlib.figure.Figure`](https://matplotlib.org/stable/api/figure_api.html?highlight=figure%20figure#matplotlib.figure.Figure)
    object and the
    [`matplotlib.axes.Axes`](https://matplotlib.org/stable/api/axes_api.html?highlight=axes%20axes#the-axes-class)
    object used for plotting
    &#34;&#34;&#34;
    if self.needs_update:
        self.update()
    if fig is None and axs is None:
        fig, axs = plt.subplots(1, 1)

    for what_to_plot in plot_what:

        if what_to_plot == &#39;airfoil&#39;:
            for idx, C in enumerate(self.C):
                if plot_kwargs is None:
                    if idx == 0:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;, label=&#39;airfoil&#39;)
                    else:
                        axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], color=&#39;cornflowerblue&#39;)
                else:
                    axs.plot(C[&#39;x&#39;], C[&#39;y&#39;], **plot_kwargs[idx])

        if what_to_plot == &#39;anchor-point-skeleton&#39;:
            if plot_kwargs is None:
                axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], &#39;:x&#39;, color=&#39;black&#39;,
                         label=&#39;anchor point skeleton&#39;)
            else:
                axs.plot(self.anchor_point_array[:, 0], self.anchor_point_array[:, 1], **plot_kwargs)

        if what_to_plot == &#39;control-point-skeleton&#39;:
            if plot_kwargs is None:
                axs.plot(self.control_points[:, 0], self.control_points[:, 1], &#39;--*&#39;, color=&#39;grey&#39;,
                         label=&#39;control point skeleton&#39;)
            else:
                axs.plot(self.control_points[:, 0], self.control_points[:, 1], **plot_kwargs)
        if what_to_plot == &#39;chordline&#39;:
            if plot_kwargs is None:
                axs.plot(np.array([0 + self.dx.value, self.c.value * np.cos(self.alf.value) + self.dx.value]),
                         np.array([0 + self.dy.value, -self.c.value * np.sin(self.alf.value) + self.dy.value]),
                         &#39;-.&#39;, color=&#39;indianred&#39;, label=&#39;chordline&#39;)
            else:
                axs.plot(np.array([0, self.c.value * np.cos(self.alf.value)]),
                         np.array([0, -self.c.value * np.sin(self.alf.value)]), **plot_kwargs)
        if what_to_plot == &#39;R-circles&#39;:
            line = [[0 + self.dx.value, self.R_le.value *
                     np.cos(self.phi_le.value - self.alf.value) + self.dx.value],
                    [0 + self.dy.value, self.R_le.value *
                     np.sin(self.phi_le.value - self.alf.value) + self.dy.value]]
            circle = plt.Circle((line[0][1], line[1][1]), self.R_le.value, fill=False, color=&#39;gold&#39;,
                                label=&#39;R circle&#39;)
            axs.plot(line[0], line[1], color=&#39;gold&#39;)
            axs.add_patch(circle)
            for anchor_point in self.anchor_point_tuple:
                xy = self.anchor_point_array[self.anchor_point_order.index(anchor_point.name), :]
                if self.anchor_point_order.index(anchor_point.name) &gt; self.anchor_point_order.index(&#39;le&#39;):
                    perp_angle = np.pi / 2
                    phi = -anchor_point.phi.value
                else:
                    perp_angle = -np.pi / 2
                    phi = anchor_point.phi.value
                line = np.array([xy, xy + anchor_point.R.value *
                                 np.array([np.cos(phi - self.alf.value + perp_angle),
                                           np.sin(phi - self.alf.value + perp_angle)])])
                circle = plt.Circle((line[1, 0], line[1, 1]), anchor_point.R.value, fill=False, color=&#39;gold&#39;)
                axs.plot(line[:, 0], line[:, 1], color=&#39;gold&#39;)
                axs.add_patch(circle)
        if what_to_plot == &#39;curvature&#39;:
            if plot_kwargs is None:
                axs.plot(self.curvature[:, 0], self.curvature[:, 1], color=&#39;cornflowerblue&#39;, label=&#39;curvature&#39;)
            else:
                axs.plot(self.curvature[:, 0], self.curvature[:, 1], **plot_kwargs)

    if axis_equal:
        axs.set_aspect(&#39;equal&#39;, &#39;box&#39;)
    if show_title:
        area = self.compute_area()
        fig.suptitle(
            fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$, $A={area:.5f}$&#39;)
    else:
        fig.suptitle(
            fr&#39;Airfoil: $c={self.c.value:.3f}$, $\alpha={np.rad2deg(self.alf.value):.3f}^\circ$&#39;)
    if tight_layout:
        fig.tight_layout()
    fig.set_figwidth(figwidth)
    fig.set_figheight(figheight)
    if show_legend:
        axs.legend()
    if save_plot:
        fig.savefig(save_path)
    if show_plot:
        plt.show()
    return fig, axs</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle: float)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.</p>
<h3 id="args">Args:</h3>
<p><code>angle</code>: Angle (in radians) by which to rotate the airfoil.</p>
<h3 id="returns">Returns:</h3>
<p>The rotated control point and anchor point arrays</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, angle: float):
    &#34;&#34;&#34;
    ### Description:

    Rotates all the control points and anchor points by a specified angle. Used to implement the angle of attack.

    ### Args:

    `angle`: Angle (in radians) by which to rotate the airfoil.

    ### Returns:

    The rotated control point and anchor point arrays
    &#34;&#34;&#34;
    rot_mat = np.array([[np.cos(angle), -np.sin(angle)],
                        [np.sin(angle), np.cos(angle)]])
    self.control_points = (rot_mat @ self.control_points.T).T
    self.anchor_point_array = (rot_mat @ self.anchor_point_array.T).T
    for key, anchor_point in self.transformed_anchor_points.items():
        self.transformed_anchor_points[key] = (rot_mat @ anchor_point.T).T
    self.needs_update = True
    return self.control_points, self.anchor_point_array</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_bezier_curve_orders"><code class="name flex">
<span>def <span class="ident">set_bezier_curve_orders</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bezier_curve_orders(self):
    for anchor_point in self.anchor_point_tuple:
        self.N[anchor_point.name] = 5
        if anchor_point.name not in self.anchor_point_order:
            self.anchor_point_order.insert(self.anchor_point_order.index(anchor_point.previous_anchor_point) + 1,
                                           anchor_point.name)
    if self.anchor_point_order.index(&#39;te_2&#39;) - self.anchor_point_order.index(&#39;le&#39;) != 1:
        self.N[&#39;le&#39;] = 5  # Set the order of the Bézier curve after the leading edge to 5
        self.N[self.anchor_point_order[-2]] = 4  # Set the order of the last Bezier curve to 4
    for free_point in self.free_point_tuple:
        # Increment the order of the modified Bézier curve
        self.N[free_point.previous_anchor_point] += 1</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_curvature"><code class="name flex">
<span>def <span class="ident">set_curvature</span></span>(<span>self, anchor_point: <a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This is the function which enforces <span><span class="MathJax_Preview">G^2</span><script type="math/tex">G^2</script></span> continuity for all <code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code>s
which are added. To keep the length ratios and angles defined in a "nice" way, the neighboring control points
to the anchor point's slope-control points are defined as follows:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\begin{bmatrix} x_{-2} \\ y_{-2} \end{bmatrix} &amp;=
\begin{cases}
\begin{bmatrix} x_{-1} + \frac{c_1}{c_2[c_3(\tan{(\theta_1)} + y_0 - y_{-1})]}
\\ \tan{(\theta_1)} (x_{-2} - x_{-1}) + y_{-1} \end{bmatrix}
,&amp; \theta_1 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
\begin{bmatrix} x_{-1} \\ y_{-1} + \frac{c_1}{c_2 c_3}
\end{bmatrix},&amp; \theta_1 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
R \in (-\infty,0)
\cup (0,\infty) \\
\begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix},&amp; \theta_1 \in (-\infty, \infty) \wedge R =
\pm \infty
\end{cases} \\
\begin{bmatrix} x_{+2} \\ y_{+2} \end{bmatrix} &amp;=
\begin{cases}
\begin{bmatrix} x_{+1} + \frac{c_4}{c_5[c_6(\tan{(\theta_2)} + y_{+1} - y_0)]}
\\ \tan{(\theta_2)} (x_{+2} - x_{+1}) + y_{+1} \end{bmatrix}
,&amp; \theta_2 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
\begin{bmatrix} x_{+1} \\ y_{+1} + \frac{c_4}{c_5 c_6}
\end{bmatrix},&amp; \theta_2 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
R \in (-\infty,0)
\cup (0,\infty) \\
\begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix},&amp; \theta_2 \in (-\infty, \infty) \wedge R =
\pm \infty
\end{cases}
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
\begin{bmatrix} x_{-2} \\ y_{-2} \end{bmatrix} &=
\begin{cases}
\begin{bmatrix} x_{-1} + \frac{c_1}{c_2[c_3(\tan{(\theta_1)} + y_0 - y_{-1})]}
\\ \tan{(\theta_1)} (x_{-2} - x_{-1}) + y_{-1} \end{bmatrix}
,& \theta_1 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
\begin{bmatrix} x_{-1} \\ y_{-1} + \frac{c_1}{c_2 c_3}
\end{bmatrix},& \theta_1 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
R \in (-\infty,0)
\cup (0,\infty) \\
\begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix},& \theta_1 \in (-\infty, \infty) \wedge R =
\pm \infty
\end{cases} \\
\begin{bmatrix} x_{+2} \\ y_{+2} \end{bmatrix} &=
\begin{cases}
\begin{bmatrix} x_{+1} + \frac{c_4}{c_5[c_6(\tan{(\theta_2)} + y_{+1} - y_0)]}
\\ \tan{(\theta_2)} (x_{+2} - x_{+1}) + y_{+1} \end{bmatrix}
,& \theta_2 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
\begin{bmatrix} x_{+1} \\ y_{+1} + \frac{c_4}{c_5 c_6}
\end{bmatrix},& \theta_2 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
R \in (-\infty,0)
\cup (0,\infty) \\
\begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix},& \theta_2 \in (-\infty, \infty) \wedge R =
\pm \infty
\end{cases}
\end{align*}
</script></span>
where
<span><span class="MathJax_Preview">
\begin{align*}
c_1 &amp;= \frac{-1}{R}[(x_0-x_{-1})^2 + (y_0-y_{-1})^2]^{3/2} \\
c_2 &amp;= 1 - \frac{1}{n_1} \\
c_3 &amp;= x_{-1} - x_0 \\
c_4 &amp;= \frac{-1}{R}[(x_{+1}-x_0)^2 + (y_{+1}-y_0)^2]^{3/2} \\
c_5 &amp;= 1 - \frac{1}{n_2} \\
c_6 &amp;= x_0 - x_{+1}
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
c_1 &= \frac{-1}{R}[(x_0-x_{-1})^2 + (y_0-y_{-1})^2]^{3/2} \\
c_2 &= 1 - \frac{1}{n_1} \\
c_3 &= x_{-1} - x_0 \\
c_4 &= \frac{-1}{R}[(x_{+1}-x_0)^2 + (y_{+1}-y_0)^2]^{3/2} \\
c_5 &= 1 - \frac{1}{n_2} \\
c_6 &= x_0 - x_{+1}
\end{align*}
</script></span></p>
<p>Here, <span><span class="MathJax_Preview">n_1</span><script type="math/tex">n_1</script></span> is the order of the Bézier curve preceding the anchor point, and <span><span class="MathJax_Preview">n_2</span><script type="math/tex">n_2</script></span> is the order of the
Bézier curve following the anchor point. <span><span class="MathJax_Preview">(x_0,y_0)</span><script type="math/tex">(x_0,y_0)</script></span> is the anchor point location, <span><span class="MathJax_Preview">(x_{-1},y_{-1})</span><script type="math/tex">(x_{-1},y_{-1})</script></span>
and <span><span class="MathJax_Preview">(x_{+1},y_{+1})</span><script type="math/tex">(x_{+1},y_{+1})</script></span> are the neighboring control points, and <span><span class="MathJax_Preview">(x_{-2},y_{-2})</span><script type="math/tex">(x_{-2},y_{-2})</script></span> and <span><span class="MathJax_Preview">(x_{+2},y_{+2})</span><script type="math/tex">(x_{+2},y_{+2})</script></span>
are the curvature control points. <span><span class="MathJax_Preview">\theta_1</span><script type="math/tex">\theta_1</script></span> and <span><span class="MathJax_Preview">\theta_2</span><script type="math/tex">\theta_2</script></span> are governed by the following relationships:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\theta_1 &amp;=
\begin{cases}
\psi_1 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
\pi + \psi_2 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
\pi - \psi_1 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
-\psi_2 - \phi,&amp; R &lt; 0,\,\text{lower surface}
\end{cases} \\
\theta_2 &amp;=
\begin{cases}
-\psi_2 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
\psi_1 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
\pi + \psi_2 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
\psi_1 - \phi,&amp; R &lt; 0,\,\text{lower surface}
\end{cases}
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
\theta_1 &=
\begin{cases}
\psi_1 + \phi,& R > 0,\,\text{upper surface} \\
\pi + \psi_2 - \phi,& R > 0,\,\text{lower surface} \\
\pi - \psi_1 + \phi,& R < 0,\,\text{upper surface} \\
-\psi_2 - \phi,& R < 0,\,\text{lower surface}
\end{cases} \\
\theta_2 &=
\begin{cases}
-\psi_2 + \phi,& R > 0,\,\text{upper surface} \\
\psi_1 - \phi,& R > 0,\,\text{lower surface} \\
\pi + \psi_2 + \phi,& R < 0,\,\text{upper surface} \\
\psi_1 - \phi,& R < 0,\,\text{lower surface}
\end{cases}
\end{align*}
</script></span>
By these definitions of the curvature control arm angles, decreasing <span><span class="MathJax_Preview">\psi_1</span><script type="math/tex">\psi_1</script></span> or <span><span class="MathJax_Preview">\psi_2</span><script type="math/tex">\psi_2</script></span> from
<span><span class="MathJax_Preview">90^{\circ}</span><script type="math/tex">90^{\circ}</script></span> has the effect of "tucking" the arms in, and increasing <span><span class="MathJax_Preview">\psi_1</span><script type="math/tex">\psi_1</script></span> or <span><span class="MathJax_Preview">\psi_2</span><script type="math/tex">\psi_2</script></span> from
<span><span class="MathJax_Preview">90^{\circ}</span><script type="math/tex">90^{\circ}</script></span> has the effect of "spreading" the arms out. See the documentation for
<code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code> for further description and a visual.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;A value of <span><span class="MathJax_Preview"> R = \frac{1}{\kappa} = 0 </span><script type="math/tex"> R = \frac{1}{\kappa} = 0 </script></span> (infinite curvature) is not well-defined for geometric shapes. Setting <span><span class="MathJax_Preview">R = 0</span><script type="math/tex">R = 0</script></span> will yield an exception.</p>
</div>
<h3 id="returns">Returns:</h3>
<p>The generated curvature control point <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> - <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> locations as <code>np.ndarray</code>s of <code>shape=2</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curvature(self, anchor_point: AnchorPoint):
    r&#34;&#34;&#34;
    ### Description:

    This is the function which enforces \(G^2\) continuity for all `pyairpar.core.anchor_point.AnchorPoint`s
    which are added. To keep the length ratios and angles defined in a &#34;nice&#34; way, the neighboring control points
    to the anchor point&#39;s slope-control points are defined as follows:

    $$
    \begin{align*}
        \begin{bmatrix} x_{-2} \\ y_{-2} \end{bmatrix} &amp;=
        \begin{cases}
            \begin{bmatrix} x_{-1} + \frac{c_1}{c_2[c_3(\tan{(\theta_1)} + y_0 - y_{-1})]}
                            \\ \tan{(\theta_1)} (x_{-2} - x_{-1}) + y_{-1} \end{bmatrix}
                            ,&amp; \theta_1 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
            \begin{bmatrix} x_{-1} \\ y_{-1} + \frac{c_1}{c_2 c_3}  \end{bmatrix},&amp; \theta_1 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
                                                                                                R \in (-\infty,0)
                                                                                                \cup (0,\infty) \\
            \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix},&amp; \theta_1 \in (-\infty, \infty) \wedge R =
                                                                                                        \pm \infty
        \end{cases} \\
        \begin{bmatrix} x_{+2} \\ y_{+2} \end{bmatrix} &amp;=
        \begin{cases}
            \begin{bmatrix} x_{+1} + \frac{c_4}{c_5[c_6(\tan{(\theta_2)} + y_{+1} - y_0)]}
                            \\ \tan{(\theta_2)} (x_{+2} - x_{+1}) + y_{+1} \end{bmatrix}
                            ,&amp; \theta_2 \neq \frac{\pi}{2} + k\pi \text{ for integer } k \wedge R \in (-\infty,0) \cup (0, \infty) \\
            \begin{bmatrix} x_{+1} \\ y_{+1} + \frac{c_4}{c_5 c_6}  \end{bmatrix},&amp; \theta_2 = \frac{\pi}{2} + k\pi \text{ for integer } k \wedge
                                                                                                R \in (-\infty,0)
                                                                                                \cup (0,\infty) \\
            \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix},&amp; \theta_2 \in (-\infty, \infty) \wedge R =
                                                                                                        \pm \infty
        \end{cases}
    \end{align*}
    $$
    where
    $$
    \begin{align*}
    c_1 &amp;= \frac{-1}{R}[(x_0-x_{-1})^2 + (y_0-y_{-1})^2]^{3/2} \\
    c_2 &amp;= 1 - \frac{1}{n_1} \\
    c_3 &amp;= x_{-1} - x_0 \\
    c_4 &amp;= \frac{-1}{R}[(x_{+1}-x_0)^2 + (y_{+1}-y_0)^2]^{3/2} \\
    c_5 &amp;= 1 - \frac{1}{n_2} \\
    c_6 &amp;= x_0 - x_{+1}
    \end{align*}
    $$

    Here, \(n_1\) is the order of the Bézier curve preceding the anchor point, and \(n_2\) is the order of the
    Bézier curve following the anchor point. \((x_0,y_0)\) is the anchor point location, \((x_{-1},y_{-1})\)
    and \((x_{+1},y_{+1})\) are the neighboring control points, and \((x_{-2},y_{-2})\) and \((x_{+2},y_{+2})\)
    are the curvature control points. \(\theta_1\) and \(\theta_2\) are governed by the following relationships:

    $$
    \begin{align*}
        \theta_1 &amp;=
        \begin{cases}
            \psi_1 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
            \pi + \psi_2 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
            \pi - \psi_1 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
            -\psi_2 - \phi,&amp; R &lt; 0,\,\text{lower surface}
        \end{cases} \\
        \theta_2 &amp;=
        \begin{cases}
            -\psi_2 + \phi,&amp; R &gt; 0,\,\text{upper surface} \\
            \psi_1 - \phi,&amp; R &gt; 0,\,\text{lower surface} \\
            \pi + \psi_2 + \phi,&amp; R &lt; 0,\,\text{upper surface} \\
            \psi_1 - \phi,&amp; R &lt; 0,\,\text{lower surface}
        \end{cases}
    \end{align*}
    $$
    By these definitions of the curvature control arm angles, decreasing \(\psi_1\) or \(\psi_2\) from
    \(90^{\circ}\) has the effect of &#34;tucking&#34; the arms in, and increasing \(\psi_1\) or \(\psi_2\) from
    \(90^{\circ}\) has the effect of &#34;spreading&#34; the arms out. See the documentation for
    `pyairpar.core.anchor_point.AnchorPoint` for further description and a visual.

    .. note:: A value of \( R = \frac{1}{\kappa} = 0 \) (infinite curvature) is not well-defined for geometric shapes. Setting \(R = 0\) will yield an exception.

    ### Returns:

    The generated curvature control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
    &#34;&#34;&#34;
    R = anchor_point.R.value
    if R == np.inf or R == -np.inf:
        self.g2_minus_points[anchor_point.name] = self.g1_minus_points[anchor_point.name]
        self.g2_plus_points[anchor_point.name] = self.g1_plus_points[anchor_point.name]
        g2_minus_point = self.g2_minus_points[anchor_point.name]
        g2_plus_point = self.g2_plus_points[anchor_point.name]
    else:
        n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(anchor_point.name) - 1]], \
                 self.N[anchor_point.name]
        if R &gt; 0:  # If the radius of curvature is positive,
            if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
                theta1, theta2 = anchor_point.psi1.value + anchor_point.phi.value, \
                                 -anchor_point.psi2.value + anchor_point.phi.value
            else:
                theta2, theta1 = - anchor_point.psi1.value - anchor_point.phi.value, \
                                 np.pi + anchor_point.psi2.value - anchor_point.phi.value
        else:  # If the radius of curvature is negative,
            if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
                theta1, theta2 = np.pi - anchor_point.psi1.value + anchor_point.phi.value, \
                                 np.pi + anchor_point.psi2.value + anchor_point.phi.value
            else:
                theta2, theta1 = anchor_point.psi1.value - anchor_point.phi.value, \
                                 -anchor_point.psi2.value - anchor_point.phi.value
        x0, y0 = anchor_point.xy[0], anchor_point.xy[1]

        x_m1, y_m1 = self.g1_minus_points[anchor_point.name][0], self.g1_minus_points[anchor_point.name][1]
        g2_minus_point = np.zeros(2)
        c1 = - 1 / R * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3 / 2)
        c2 = 1 - 1 / n1
        c3 = x_m1 - x0
        if (theta1 - np.pi / 2) % np.pi != 0:
            g2_minus_point[0] = x_m1 + c1 / c2 / (c3 * np.tan(theta1) + y0 - y_m1)
            g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1
        else:
            g2_minus_point[0] = x_m1
            g2_minus_point[1] = y_m1 + c1 / c2 / c3

        x_p1, y_p1 = self.g1_plus_points[anchor_point.name][0], self.g1_plus_points[anchor_point.name][1]
        g2_plus_point = np.zeros(2)
        c4 = - 1 / R * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3 / 2)
        c5 = 1 - 1 / n2
        c6 = x0 - x_p1
        if (theta2 - np.pi / 2) % np.pi != 0:
            g2_plus_point[0] = x_p1 + c4 / c5 / (c6 * np.tan(theta2) + y_p1 - y0)
            g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1
        else:
            g2_plus_point[0] = x_p1
            g2_plus_point[1] = y_p1 + c4 / c5 / c6

        self.g2_minus_points[anchor_point.name] = g2_minus_point
        self.g2_plus_points[anchor_point.name] = g2_plus_point

    return g2_minus_point, g2_plus_point</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_curvature_le"><code class="name flex">
<span>def <span class="ident">set_curvature_le</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>See the description of <code><a title="pyairpar.core.airfoil.Airfoil.set_curvature" href="#pyairpar.core.airfoil.Airfoil.set_curvature">Airfoil.set_curvature()</a></code>. This is just a special case of that
function tailored for the leading edge of the airfoil. Here, <span><span class="MathJax_Preview">\psi_1</span><script type="math/tex">\psi_1</script></span> defines the angle of the upper
curvature control arm, and <span><span class="MathJax_Preview">\psi_2</span><script type="math/tex">\psi_2</script></span> defines the angle of the lower curvature control arm. See also
<code><a title="pyairpar.core.base_airfoil_params.BaseAirfoilParams" href="base_airfoil_params.html#pyairpar.core.base_airfoil_params.BaseAirfoilParams">BaseAirfoilParams</a></code> for more details on the definitions of the attribute
parameters input to this function.</p>
<h3 id="returns">Returns:</h3>
<p>The generated curvature control point <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> - <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> locations as <code>np.ndarray</code>s of <code>shape=2</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curvature_le(self):
    r&#34;&#34;&#34;
    ### Description:

    See the description of `pyairpar.core.airfoil.Airfoil.set_curvature()`. This is just a special case of that
    function tailored for the leading edge of the airfoil. Here, \(\psi_1\) defines the angle of the upper
    curvature control arm, and \(\psi_2\) defines the angle of the lower curvature control arm. See also
    `pyairpar.core.base_airfoil_params.BaseAirfoilParams` for more details on the definitions of the attribute
    parameters input to this function.

    ### Returns:

    The generated curvature control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
    &#34;&#34;&#34;
    if self.R_le.value == np.inf or self.R_le.value == -np.inf:
        g2_minus_point = self.g1_minus_points[&#39;le&#39;]
        g2_plus_point = self.g1_plus_points[&#39;le&#39;]
    else:
        n1, n2 = self.N[self.anchor_point_order[self.anchor_point_order.index(&#39;le&#39;) - 1]], self.N[&#39;le&#39;]
        theta1, theta2 = self.psi1_le.value, -self.psi2_le.value
        x0, y0 = self.anchor_points[&#39;le&#39;][0], self.anchor_points[&#39;le&#39;][1]

        x_m1, y_m1 = self.g1_minus_points[&#39;le&#39;][0], self.g1_minus_points[&#39;le&#39;][1]
        g2_minus_point = np.zeros(2)
        g2_minus_point[0] = x_m1 - 1 / self.R_le.value * ((x0 - x_m1) ** 2 + (y0 - y_m1) ** 2) ** (3/2) / (
                            1 - 1 / n1) / ((x_m1 - x0) * np.tan(theta1) + y0 - y_m1)
        g2_minus_point[1] = np.tan(theta1) * (g2_minus_point[0] - x_m1) + y_m1

        x_p1, y_p1 = self.g1_plus_points[&#39;le&#39;][0], self.g1_plus_points[&#39;le&#39;][1]
        g2_plus_point = np.zeros(2)
        g2_plus_point[0] = x_p1 - 1 / self.R_le.value * ((x_p1 - x0) ** 2 + (y_p1 - y0) ** 2) ** (3/2) / (
                           1 - 1 / n2) / ((x0 - x_p1) * np.tan(theta2) + y_p1 - y0)
        g2_plus_point[1] = np.tan(theta2) * (g2_plus_point[0] - x_p1) + y_p1

    return g2_minus_point, g2_plus_point</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.set_slope"><code class="name flex">
<span>def <span class="ident">set_slope</span></span>(<span>self, anchor_point: <a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This is the function which enforces <span><span class="MathJax_Preview">G^1</span><script type="math/tex">G^1</script></span> continuity for all <code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code>s
which are added. To keep the length ratios and angles defined in a "nice" way, the neighboring control points
to the anchor point are defined as follows: For anchor points on the upper surface (where <span><span class="MathJax_Preview">(x_0,
y_0)</span><script type="math/tex">(x_0,
y_0)</script></span> precedes the leading edge point):</p>
<p><span><span class="MathJax_Preview">\begin{align*}
\begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
(1-r)L \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix} \\
\begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
rL \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix}
\end{align*}</span><script type="math/tex; mode=display">\begin{align*}
\begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
(1-r)L \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix} \\
\begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
rL \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix}
\end{align*}</script></span></p>
<p>For anchor points on the lower surface (where <span><span class="MathJax_Preview">(x_0,y_0)</span><script type="math/tex">(x_0,y_0)</script></span> occurs further down the Bézier curve path than
the leading edge point):</p>
<p><span><span class="MathJax_Preview">\begin{align*}
\begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
rL \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix} \\
\begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
(1-r)L \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix}
\end{align*}</span><script type="math/tex; mode=display">\begin{align*}
\begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
rL \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix} \\
\begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
(1-r)L \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix}
\end{align*}</script></span></p>
<p>Here, <span><span class="MathJax_Preview">(x_{-1},y_{-1})</span><script type="math/tex">(x_{-1},y_{-1})</script></span> represents the coordinates of the "minus" point (the control point before the
leading edge point), and <span><span class="MathJax_Preview">(x_{+1},y_{+1})</span><script type="math/tex">(x_{+1},y_{+1})</script></span> represents the coordinates of the "plus" point (the control
point after the leading edge point). The coordinates of the anchor point itself are <span><span class="MathJax_Preview">(x_0,y_0)</span><script type="math/tex">(x_0,y_0)</script></span>. With
these definitions, a ratio <span><span class="MathJax_Preview">r&gt;0.5</span><script type="math/tex">r>0.5</script></span> biases the neighboring control points toward the leading edge, and
a ratio <span><span class="MathJax_Preview">r&lt;0.5</span><script type="math/tex">r<0.5</script></span> biases the neighboring control points toward the leading edge. A positive value of <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span>
angles the neighboring control points toward the trailing edge, and a negative value of <span><span class="MathJax_Preview">\phi</span><script type="math/tex">\phi</script></span> angles the
neighboring control points toward the trailing edge. See the diagram for
<code><a title="pyairpar.core.anchor_point.AnchorPoint" href="anchor_point.html#pyairpar.core.anchor_point.AnchorPoint">AnchorPoint</a></code> for a visual description of these definitions.</p>
<h3 id="returns">Returns:</h3>
<p>The generated neighboring control point <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> - <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> locations as <code>np.ndarray</code>s of <code>shape=2</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slope(self, anchor_point: AnchorPoint):
    r&#34;&#34;&#34;
    ### Description:

    This is the function which enforces \(G^1\) continuity for all `pyairpar.core.anchor_point.AnchorPoint`s
    which are added. To keep the length ratios and angles defined in a &#34;nice&#34; way, the neighboring control points
    to the anchor point are defined as follows: For anchor points on the upper surface (where \((x_0,
    y_0)\) precedes the leading edge point):

    $$\begin{align*}
    \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
    (1-r)L \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix} \\
    \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
    rL \begin{bmatrix} \cos{\phi} \\ \sin{\phi} \end{bmatrix}
    \end{align*}$$

    For anchor points on the lower surface (where \((x_0,y_0)\) occurs further down the Bézier curve path than
    the leading edge point):

    $$\begin{align*}
    \begin{bmatrix} x_{-1} \\ y_{-1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} -
    rL \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix} \\
    \begin{bmatrix} x_{+1} \\ y_{+1} \end{bmatrix} &amp;= \begin{bmatrix} x_0 \\ y_0 \end{bmatrix} +
    (1-r)L \begin{bmatrix} \cos{(-\phi)} \\ \sin{(-\phi)} \end{bmatrix}
    \end{align*}$$

    Here, \((x_{-1},y_{-1})\) represents the coordinates of the &#34;minus&#34; point (the control point before the
    leading edge point), and \((x_{+1},y_{+1})\) represents the coordinates of the &#34;plus&#34; point (the control
    point after the leading edge point). The coordinates of the anchor point itself are \((x_0,y_0)\). With
    these definitions, a ratio \(r&gt;0.5\) biases the neighboring control points toward the leading edge, and
    a ratio \(r&lt;0.5\) biases the neighboring control points toward the leading edge. A positive value of \(\phi\)
    angles the neighboring control points toward the trailing edge, and a negative value of \(\phi\) angles the
    neighboring control points toward the trailing edge. See the diagram for
    `pyairpar.core.anchor_point.AnchorPoint` for a visual description of these definitions.

    ### Returns:

    The generated neighboring control point \(x\) - \(y\) locations as `np.ndarray`s of `shape=2`.
    &#34;&#34;&#34;
    r = anchor_point.r.value
    L = anchor_point.L.value
    phi = anchor_point.phi.value

    if self.anchor_point_order.index(anchor_point.name) &lt; self.anchor_point_order.index(&#39;le&#39;):
        self.g1_minus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(phi), np.sin(phi)])
        self.g1_plus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(phi), np.sin(phi)])
    else:
        self.g1_minus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] - r * L * np.array([np.cos(-phi), np.sin(-phi)])
        self.g1_plus_points[anchor_point.name] = \
            self.anchor_points[anchor_point.name] + (1 - r) * L * np.array([np.cos(-phi), np.sin(-phi)])
    return self.g1_minus_points[anchor_point.name], self.g1_plus_points[anchor_point.name]</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, dx: float, dy: float)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>Translates all the control points and anchor points by <span><span class="MathJax_Preview">\Delta x</span><script type="math/tex">\Delta x</script></span> and <span><span class="MathJax_Preview">\Delta y</span><script type="math/tex">\Delta y</script></span>.</p>
<h3 id="args">Args:</h3>
<p><code>dx</code>: <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>-direction translation magnitude</p>
<p><code>dy</code>: <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>-direction translation magnitude</p>
<h3 id="returns">Returns:</h3>
<p>The translated control point and anchor point arrays</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, dx: float, dy: float):
    &#34;&#34;&#34;
    ### Description:

    Translates all the control points and anchor points by \\(\\Delta x\\) and \\(\\Delta y\\).

    ### Args:

    `dx`: \\(x\\)-direction translation magnitude

    `dy`: \\(y\\)-direction translation magnitude

    ### Returns:

    The translated control point and anchor point arrays
    &#34;&#34;&#34;
    self.control_points[:, 0] += dx
    self.control_points[:, 1] += dy
    self.anchor_point_array[:, 0] += dx
    self.anchor_point_array[:, 1] += dy
    for key, anchor_point in self.transformed_anchor_points.items():
        self.transformed_anchor_points[key] = anchor_point + np.array([dx, dy])
    self.needs_update = True
    return self.control_points, self.anchor_point_array</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>The <code>update</code> function adds first all of the anchor points in the <code>anchor_point_tuple</code> and then all of the free
points in the <code>free_point_tuple</code>. The parameter information is extracted. The control points are ordered
based on the <code>anchor_point_order</code>, <code>name</code> attributes, and <code>previous_anchor_point</code> attributes. The
<code>anchor_point_array</code> is updated based on the anchor points added. Airfoil coordinates are generated and saved.
Rotation to the specified angle of attack
and translation by the specified <span><span class="MathJax_Preview">\Delta x</span><script type="math/tex">\Delta x</script></span>, <span><span class="MathJax_Preview">\Delta y</span><script type="math/tex">\Delta y</script></span> are applied, in that order. The Bézier
curves are generated through the control points and the airfoil coordinates are then calculated again after
the transformations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    r&#34;&#34;&#34;
    ### Description:

    The `update` function adds first all of the anchor points in the `anchor_point_tuple` and then all of the free
    points in the `free_point_tuple`. The parameter information is extracted. The control points are ordered
    based on the `anchor_point_order`, `name` attributes, and `previous_anchor_point` attributes. The
    `anchor_point_array` is updated based on the anchor points added. Airfoil coordinates are generated and saved.
    Rotation to the specified angle of attack
    and translation by the specified \(\Delta x\), \(\Delta y\) are applied, in that order. The Bézier
    curves are generated through the control points and the airfoil coordinates are then calculated again after
    the transformations.
    &#34;&#34;&#34;
    self.set_bezier_curve_orders()
    self.add_anchor_points()
    self.add_free_points()
    self.extract_parameters()
    self.order_control_points()
    self.update_anchor_point_array()
    self.generate_non_transformed_airfoil_coordinates()
    self.rotate(-self.alf.value)
    self.translate(self.dx.value, self.dy.value)
    self.generate_airfoil_coordinates()
    self.needs_update = False</code></pre>
</details>
</dd>
<dt id="pyairpar.core.airfoil.Airfoil.update_anchor_point_array"><code class="name flex">
<span>def <span class="ident">update_anchor_point_array</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="description">Description:</h3>
<p>This function updates the <code>anchor_point_array</code> attribute of <code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code>, which is a
<code>np.ndarray</code> of <code>shape=(N, 2)</code>, where <code>N</code> is the number of anchor points in the airfoil, and the columns
represent the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_anchor_point_array(self):
    r&#34;&#34;&#34;
    ### Description:

    This function updates the `anchor_point_array` attribute of `pyairpar.core.airfoil.Airfoil`, which is a
    `np.ndarray` of `shape=(N, 2)`, where `N` is the number of anchor points in the airfoil, and the columns
    represent the \(x\) and \(y\) coordinates.
    &#34;&#34;&#34;
    for key in self.anchor_point_order:
        xy = self.anchor_points[key]
        if key == &#39;te_1&#39;:
            self.anchor_point_array = xy
        else:
            self.anchor_point_array = np.row_stack((self.anchor_point_array, xy))
    self.transformed_anchor_points = deepcopy(self.anchor_points)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyairpar.core" href="index.html">pyairpar.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyairpar.core.airfoil.bezier" href="#pyairpar.core.airfoil.bezier">bezier</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyairpar.core.airfoil.Airfoil" href="#pyairpar.core.airfoil.Airfoil">Airfoil</a></code></h4>
<ul class="">
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_anchor_point" href="#pyairpar.core.airfoil.Airfoil.add_anchor_point">add_anchor_point</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_anchor_points" href="#pyairpar.core.airfoil.Airfoil.add_anchor_points">add_anchor_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_free_point" href="#pyairpar.core.airfoil.Airfoil.add_free_point">add_free_point</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.add_free_points" href="#pyairpar.core.airfoil.Airfoil.add_free_points">add_free_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.check_self_intersection" href="#pyairpar.core.airfoil.Airfoil.check_self_intersection">check_self_intersection</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.compute_area" href="#pyairpar.core.airfoil.Airfoil.compute_area">compute_area</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.compute_thickness" href="#pyairpar.core.airfoil.Airfoil.compute_thickness">compute_thickness</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.extract_parameters" href="#pyairpar.core.airfoil.Airfoil.extract_parameters">extract_parameters</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.generate_airfoil_coordinates" href="#pyairpar.core.airfoil.Airfoil.generate_airfoil_coordinates">generate_airfoil_coordinates</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.generate_coords" href="#pyairpar.core.airfoil.Airfoil.generate_coords">generate_coords</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.generate_non_transformed_airfoil_coordinates" href="#pyairpar.core.airfoil.Airfoil.generate_non_transformed_airfoil_coordinates">generate_non_transformed_airfoil_coordinates</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.init_g1_points" href="#pyairpar.core.airfoil.Airfoil.init_g1_points">init_g1_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.init_g2_points" href="#pyairpar.core.airfoil.Airfoil.init_g2_points">init_g2_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.order_control_points" href="#pyairpar.core.airfoil.Airfoil.order_control_points">order_control_points</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.override" href="#pyairpar.core.airfoil.Airfoil.override">override</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.plot" href="#pyairpar.core.airfoil.Airfoil.plot">plot</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.rotate" href="#pyairpar.core.airfoil.Airfoil.rotate">rotate</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_bezier_curve_orders" href="#pyairpar.core.airfoil.Airfoil.set_bezier_curve_orders">set_bezier_curve_orders</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_curvature" href="#pyairpar.core.airfoil.Airfoil.set_curvature">set_curvature</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_curvature_le" href="#pyairpar.core.airfoil.Airfoil.set_curvature_le">set_curvature_le</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.set_slope" href="#pyairpar.core.airfoil.Airfoil.set_slope">set_slope</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.translate" href="#pyairpar.core.airfoil.Airfoil.translate">translate</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.update" href="#pyairpar.core.airfoil.Airfoil.update">update</a></code></li>
<li><code><a title="pyairpar.core.airfoil.Airfoil.update_anchor_point_array" href="#pyairpar.core.airfoil.Airfoil.update_anchor_point_array">update_anchor_point_array</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>